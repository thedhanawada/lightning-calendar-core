{"version":3,"file":"calendar-core.esm.min.js","sources":["../../core/core/timezone/TimezoneManager.js","../../core/core/events/Event.js","../../core/core/calendar/DateUtils.js","../../core/core/events/RecurrenceEngine.js","../../core/core/performance/LRUCache.js","../../core/core/performance/PerformanceOptimizer.js","../../core/core/conflicts/ConflictDetector.js","../../core/core/events/EventStore.js","../../core/core/state/StateManager.js","../../core/core/calendar/Calendar.js","../../core/index.js"],"sourcesContent":["/**\n * TimezoneManager - Comprehensive timezone handling for global calendar operations\n * Handles timezone conversions, DST transitions, and IANA timezone database\n *\n * Critical for Salesforce orgs spanning multiple timezones\n */\n\nexport class TimezoneManager {\n    constructor() {\n        // Cache timezone offsets for performance\n        this.offsetCache = new Map();\n        this.dstCache = new Map();\n\n        // Common timezone abbreviations to IANA mapping\n        this.timezoneAbbreviations = {\n            'EST': 'America/New_York',\n            'EDT': 'America/New_York',\n            'CST': 'America/Chicago',\n            'CDT': 'America/Chicago',\n            'MST': 'America/Denver',\n            'MDT': 'America/Denver',\n            'PST': 'America/Los_Angeles',\n            'PDT': 'America/Los_Angeles',\n            'GMT': 'Europe/London',\n            'BST': 'Europe/London',\n            'CET': 'Europe/Paris',\n            'CEST': 'Europe/Paris',\n            'JST': 'Asia/Tokyo',\n            'IST': 'Asia/Kolkata',\n            'AEST': 'Australia/Sydney',\n            'AEDT': 'Australia/Sydney'\n        };\n\n        // IANA timezone offset rules (simplified - in production would use Intl API or timezone database)\n        this.timezoneOffsets = {\n            'UTC': 0,\n            'America/New_York': -5,\n            'America/Chicago': -6,\n            'America/Denver': -7,\n            'America/Los_Angeles': -8,\n            'America/Phoenix': -7, // No DST\n            'Europe/London': 0,\n            'Europe/Paris': 1,\n            'Europe/Berlin': 1,\n            'Asia/Tokyo': 9,\n            'Asia/Shanghai': 8,\n            'Asia/Kolkata': 5.5,\n            'Australia/Sydney': 10,\n            'Pacific/Auckland': 12\n        };\n\n        // DST rules (simplified - real implementation would be more complex)\n        this.dstRules = {\n            'America/New_York': { start: { month: 3, week: 2, day: 0 }, end: { month: 11, week: 1, day: 0 }, offset: 1 },\n            'America/Chicago': { start: { month: 3, week: 2, day: 0 }, end: { month: 11, week: 1, day: 0 }, offset: 1 },\n            'America/Denver': { start: { month: 3, week: 2, day: 0 }, end: { month: 11, week: 1, day: 0 }, offset: 1 },\n            'America/Los_Angeles': { start: { month: 3, week: 2, day: 0 }, end: { month: 11, week: 1, day: 0 }, offset: 1 },\n            'Europe/London': { start: { month: 3, week: -1, day: 0 }, end: { month: 10, week: -1, day: 0 }, offset: 1 },\n            'Europe/Paris': { start: { month: 3, week: -1, day: 0 }, end: { month: 10, week: -1, day: 0 }, offset: 1 },\n            'Australia/Sydney': { start: { month: 10, week: 1, day: 0 }, end: { month: 4, week: 1, day: 0 }, offset: 1 }\n        };\n    }\n\n    /**\n     * Convert date from one timezone to another\n     * @param {Date} date - Date to convert\n     * @param {string} fromTimezone - Source timezone (IANA identifier)\n     * @param {string} toTimezone - Target timezone (IANA identifier)\n     * @returns {Date} Converted date\n     */\n    convertTimezone(date, fromTimezone, toTimezone) {\n        if (!date) return null;\n        if (fromTimezone === toTimezone) return new Date(date);\n\n        // Get offset difference\n        const fromOffset = this.getTimezoneOffset(date, fromTimezone);\n        const toOffset = this.getTimezoneOffset(date, toTimezone);\n        const offsetDiff = (toOffset - fromOffset) * 60 * 1000; // Convert to milliseconds\n\n        return new Date(date.getTime() + offsetDiff);\n    }\n\n    /**\n     * Convert date to UTC\n     * @param {Date} date - Date in local timezone\n     * @param {string} timezone - Source timezone\n     * @returns {Date} Date in UTC\n     */\n    toUTC(date, timezone) {\n        if (!date) return null;\n        if (timezone === 'UTC') return new Date(date);\n\n        const offset = this.getTimezoneOffset(date, timezone);\n        return new Date(date.getTime() - (offset * 60 * 1000));\n    }\n\n    /**\n     * Convert UTC date to timezone\n     * @param {Date} utcDate - Date in UTC\n     * @param {string} timezone - Target timezone\n     * @returns {Date} Date in specified timezone\n     */\n    fromUTC(utcDate, timezone) {\n        if (!utcDate) return null;\n        if (timezone === 'UTC') return new Date(utcDate);\n\n        const offset = this.getTimezoneOffset(utcDate, timezone);\n        return new Date(utcDate.getTime() + (offset * 60 * 1000));\n    }\n\n    /**\n     * Get timezone offset in minutes\n     * @param {Date} date - Date to check (for DST calculation)\n     * @param {string} timezone - Timezone identifier\n     * @returns {number} Offset in minutes from UTC\n     */\n    getTimezoneOffset(date, timezone) {\n        // Check cache first\n        const cacheKey = `${timezone}_${date.getFullYear()}_${date.getMonth()}_${date.getDate()}`;\n        if (this.offsetCache.has(cacheKey)) {\n            return this.offsetCache.get(cacheKey);\n        }\n\n        // Try using Intl API if available (best option for browser/Node.js environments)\n        if (typeof Intl !== 'undefined' && Intl.DateTimeFormat) {\n            try {\n                const formatter = new Intl.DateTimeFormat('en-US', {\n                    timeZone: timezone,\n                    year: 'numeric',\n                    month: '2-digit',\n                    day: '2-digit',\n                    hour: '2-digit',\n                    minute: '2-digit',\n                    second: '2-digit',\n                    hour12: false\n                });\n\n                // Create same date in target timezone\n                const parts = formatter.formatToParts(date);\n                const tzDate = new Date(\n                    parts.find(p => p.type === 'year').value,\n                    parts.find(p => p.type === 'month').value - 1,\n                    parts.find(p => p.type === 'day').value,\n                    parts.find(p => p.type === 'hour').value,\n                    parts.find(p => p.type === 'minute').value,\n                    parts.find(p => p.type === 'second').value\n                );\n\n                const offset = (tzDate.getTime() - date.getTime()) / (1000 * 60);\n                this.offsetCache.set(cacheKey, -offset);\n                return -offset;\n            } catch (e) {\n                // Fallback to manual calculation\n            }\n        }\n\n        // Fallback: Manual calculation\n        let baseOffset = (this.timezoneOffsets[timezone] || 0) * 60;\n\n        // Apply DST if applicable\n        if (this.isDST(date, timezone)) {\n            const dstRule = this.dstRules[timezone];\n            if (dstRule) {\n                baseOffset += dstRule.offset * 60;\n            }\n        }\n\n        this.offsetCache.set(cacheKey, baseOffset);\n        return baseOffset;\n    }\n\n    /**\n     * Check if date is in DST for given timezone\n     * @param {Date} date - Date to check\n     * @param {string} timezone - Timezone identifier\n     * @returns {boolean} True if in DST\n     */\n    isDST(date, timezone) {\n        const dstRule = this.dstRules[timezone];\n        if (!dstRule) return false;\n\n        const year = date.getFullYear();\n        const dstStart = this.getNthWeekdayOfMonth(year, dstRule.start.month, dstRule.start.week, dstRule.start.day);\n        const dstEnd = this.getNthWeekdayOfMonth(year, dstRule.end.month, dstRule.end.week, dstRule.end.day);\n\n        // Handle Southern Hemisphere (DST crosses year boundary)\n        if (dstStart > dstEnd) {\n            return date >= dstStart || date < dstEnd;\n        }\n\n        return date >= dstStart && date < dstEnd;\n    }\n\n    /**\n     * Get nth weekday of month\n     * @private\n     */\n    getNthWeekdayOfMonth(year, month, week, dayOfWeek) {\n        const date = new Date(year, month, 1);\n        const firstDay = date.getDay();\n\n        let dayOffset = dayOfWeek - firstDay;\n        if (dayOffset < 0) dayOffset += 7;\n\n        if (week > 0) {\n            // Nth occurrence from start\n            date.setDate(1 + dayOffset + (week - 1) * 7);\n        } else {\n            // Nth occurrence from end\n            const lastDay = new Date(year, month + 1, 0).getDate();\n            date.setDate(lastDay);\n            const lastDayOfWeek = date.getDay();\n            let offset = lastDayOfWeek - dayOfWeek;\n            if (offset < 0) offset += 7;\n            date.setDate(lastDay - offset + (week + 1) * 7);\n        }\n\n        return date;\n    }\n\n    /**\n     * Get list of common timezones\n     * @returns {Array<{value: string, label: string, offset: string}>}\n     */\n    getCommonTimezones() {\n        const now = new Date();\n        const timezones = [\n            { value: 'America/New_York', label: 'Eastern Time (New York)', region: 'Americas' },\n            { value: 'America/Chicago', label: 'Central Time (Chicago)', region: 'Americas' },\n            { value: 'America/Denver', label: 'Mountain Time (Denver)', region: 'Americas' },\n            { value: 'America/Phoenix', label: 'Mountain Time - Arizona (Phoenix)', region: 'Americas' },\n            { value: 'America/Los_Angeles', label: 'Pacific Time (Los Angeles)', region: 'Americas' },\n            { value: 'America/Anchorage', label: 'Alaska Time (Anchorage)', region: 'Americas' },\n            { value: 'Pacific/Honolulu', label: 'Hawaii Time (Honolulu)', region: 'Pacific' },\n            { value: 'America/Toronto', label: 'Eastern Time (Toronto)', region: 'Americas' },\n            { value: 'America/Vancouver', label: 'Pacific Time (Vancouver)', region: 'Americas' },\n            { value: 'America/Mexico_City', label: 'Central Time (Mexico City)', region: 'Americas' },\n            { value: 'America/Sao_Paulo', label: 'Brasilia Time (SÃ£o Paulo)', region: 'Americas' },\n            { value: 'Europe/London', label: 'GMT/BST (London)', region: 'Europe' },\n            { value: 'Europe/Paris', label: 'Central European Time (Paris)', region: 'Europe' },\n            { value: 'Europe/Berlin', label: 'Central European Time (Berlin)', region: 'Europe' },\n            { value: 'Europe/Moscow', label: 'Moscow Time', region: 'Europe' },\n            { value: 'Asia/Dubai', label: 'Gulf Time (Dubai)', region: 'Asia' },\n            { value: 'Asia/Kolkata', label: 'India Time (Mumbai)', region: 'Asia' },\n            { value: 'Asia/Shanghai', label: 'China Time (Shanghai)', region: 'Asia' },\n            { value: 'Asia/Tokyo', label: 'Japan Time (Tokyo)', region: 'Asia' },\n            { value: 'Asia/Seoul', label: 'Korea Time (Seoul)', region: 'Asia' },\n            { value: 'Asia/Singapore', label: 'Singapore Time', region: 'Asia' },\n            { value: 'Australia/Sydney', label: 'Australian Eastern Time (Sydney)', region: 'Oceania' },\n            { value: 'Australia/Melbourne', label: 'Australian Eastern Time (Melbourne)', region: 'Oceania' },\n            { value: 'Pacific/Auckland', label: 'New Zealand Time (Auckland)', region: 'Oceania' },\n            { value: 'UTC', label: 'UTC', region: 'UTC' }\n        ];\n\n        // Add current offset to each timezone\n        return timezones.map(tz => {\n            const offset = this.getTimezoneOffset(now, tz.value);\n            const offsetHours = -offset / 60; // Convert to hours from UTC\n            const hours = Math.floor(Math.abs(offsetHours));\n            const minutes = Math.round(Math.abs(offsetHours % 1) * 60);\n            const sign = offsetHours >= 0 ? '+' : '-';\n            const offsetStr = `UTC${sign}${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;\n\n            return {\n                ...tz,\n                offset: offsetStr,\n                offsetMinutes: -offset // Store in minutes for sorting\n            };\n        }).sort((a, b) => a.offsetMinutes - b.offsetMinutes);\n    }\n\n    /**\n     * Format date in specific timezone\n     * @param {Date} date - Date to format\n     * @param {string} timezone - Timezone for formatting\n     * @param {Object} options - Formatting options\n     * @returns {string} Formatted date string\n     */\n    formatInTimezone(date, timezone, options = {}) {\n        if (!date) return '';\n\n        const defaultOptions = {\n            year: 'numeric',\n            month: '2-digit',\n            day: '2-digit',\n            hour: '2-digit',\n            minute: '2-digit',\n            hour12: true,\n            timeZone: timezone\n        };\n\n        const formatOptions = { ...defaultOptions, ...options };\n\n        try {\n            return new Intl.DateTimeFormat('en-US', formatOptions).format(date);\n        } catch (e) {\n            // Fallback to basic formatting\n            const tzDate = this.fromUTC(this.toUTC(date, 'UTC'), timezone);\n            return tzDate.toLocaleString('en-US', options);\n        }\n    }\n\n    /**\n     * Get timezone from browser/system\n     * @returns {string} IANA timezone identifier\n     */\n    getSystemTimezone() {\n        if (typeof Intl !== 'undefined' && Intl.DateTimeFormat) {\n            try {\n                return Intl.DateTimeFormat().resolvedOptions().timeZone;\n            } catch (e) {\n                // Fallback\n            }\n        }\n\n        // Fallback based on offset\n        const offset = new Date().getTimezoneOffset();\n        const offsetHours = -offset / 60;\n\n        // Try to match offset to known timezone\n        for (const [tz, tzOffset] of Object.entries(this.timezoneOffsets)) {\n            if (tzOffset === offsetHours) {\n                return tz;\n            }\n        }\n\n        return 'UTC';\n    }\n\n    /**\n     * Parse timezone from string (handles abbreviations)\n     * @param {string} tzString - Timezone string\n     * @returns {string} IANA timezone identifier\n     */\n    parseTimezone(tzString) {\n        if (!tzString) return 'UTC';\n\n        // Check if it's already an IANA identifier\n        if (this.timezoneOffsets.hasOwnProperty(tzString)) {\n            return tzString;\n        }\n\n        // Check abbreviations\n        const upperTz = tzString.toUpperCase();\n        if (this.timezoneAbbreviations.hasOwnProperty(upperTz)) {\n            return this.timezoneAbbreviations[upperTz];\n        }\n\n        // Try to parse offset format (e.g., \"+05:30\", \"-08:00\")\n        const offsetMatch = tzString.match(/^([+-])(\\d{2}):?(\\d{2})$/);\n        if (offsetMatch) {\n            const sign = offsetMatch[1] === '+' ? 1 : -1;\n            const hours = parseInt(offsetMatch[2], 10);\n            const minutes = parseInt(offsetMatch[3], 10);\n            const totalOffset = sign * (hours + minutes / 60);\n\n            // Find matching timezone\n            for (const [tz, offset] of Object.entries(this.timezoneOffsets)) {\n                if (offset === totalOffset) {\n                    return tz;\n                }\n            }\n        }\n\n        return 'UTC';\n    }\n\n    /**\n     * Calculate timezone difference in hours\n     * @param {string} timezone1 - First timezone\n     * @param {string} timezone2 - Second timezone\n     * @param {Date} [date] - Date for DST calculation\n     * @returns {number} Hour difference\n     */\n    getTimezoneDifference(timezone1, timezone2, date = new Date()) {\n        const offset1 = this.getTimezoneOffset(date, timezone1);\n        const offset2 = this.getTimezoneOffset(date, timezone2);\n        return (offset2 - offset1) / 60;\n    }\n\n    /**\n     * Clear caches (useful when date changes significantly)\n     */\n    clearCache() {\n        this.offsetCache.clear();\n        this.dstCache.clear();\n    }\n}","/**\n * Event class - represents a calendar event with timezone support\n * Pure JavaScript, no DOM dependencies\n * Locker Service compatible\n */\n\nimport { TimezoneManager } from '../timezone/TimezoneManager.js';\n\nexport class Event {\n  /**\n   * Normalize event data\n   * @param {import('../../types.js').EventData} data - Raw event data\n   * @returns {import('../../types.js').EventData} Normalized event data\n   */\n  static normalize(data) {\n    const normalized = { ...data };\n\n    // Ensure dates are Date objects\n    if (normalized.start && !(normalized.start instanceof Date)) {\n      normalized.start = new Date(normalized.start);\n    }\n    if (normalized.end && !(normalized.end instanceof Date)) {\n      normalized.end = new Date(normalized.end);\n    }\n\n    // If no end date, set it to start date\n    if (!normalized.end) {\n      normalized.end = normalized.start ? new Date(normalized.start) : null;\n    }\n\n    // For all-day events, normalize times to midnight\n    if (normalized.allDay && normalized.start) {\n      normalized.start.setHours(0, 0, 0, 0);\n      if (normalized.end) {\n        normalized.end.setHours(23, 59, 59, 999);\n      }\n    }\n\n    // Normalize string fields\n    normalized.id = String(normalized.id || '').trim();\n    normalized.title = String(normalized.title || '').trim();\n    normalized.description = String(normalized.description || '').trim();\n    normalized.location = String(normalized.location || '').trim();\n\n    // Normalize arrays\n    normalized.attendees = Array.isArray(normalized.attendees) ? normalized.attendees : [];\n    normalized.reminders = Array.isArray(normalized.reminders) ? normalized.reminders : [];\n    normalized.categories = Array.isArray(normalized.categories) ? normalized.categories : [];\n    normalized.attachments = Array.isArray(normalized.attachments) ? normalized.attachments : [];\n\n    // Normalize status and visibility\n    const validStatuses = ['confirmed', 'tentative', 'cancelled'];\n    if (!validStatuses.includes(normalized.status)) {\n      normalized.status = 'confirmed';\n    }\n\n    const validVisibilities = ['public', 'private', 'confidential'];\n    if (!validVisibilities.includes(normalized.visibility)) {\n      normalized.visibility = 'public';\n    }\n\n    // Normalize colors\n    if (normalized.color && !normalized.backgroundColor) {\n      normalized.backgroundColor = normalized.color;\n    }\n    if (normalized.color && !normalized.borderColor) {\n      normalized.borderColor = normalized.color;\n    }\n\n    return normalized;\n  }\n\n  /**\n   * Validate event data\n   * @param {import('../../types.js').EventData} data - Normalized event data\n   * @throws {Error} If validation fails\n   */\n  static validate(data) {\n    // Required fields\n    if (!data.id) {\n      throw new Error('Event must have an id');\n    }\n    if (!data.title) {\n      throw new Error('Event must have a title');\n    }\n    if (!data.start) {\n      throw new Error('Event must have a start date');\n    }\n\n    // Validate dates\n    if (!(data.start instanceof Date) || isNaN(data.start.getTime())) {\n      throw new Error('Invalid start date');\n    }\n    if (data.end && (!(data.end instanceof Date) || isNaN(data.end.getTime()))) {\n      throw new Error('Invalid end date');\n    }\n\n    // Validate date order\n    if (data.end && data.start && data.end < data.start) {\n      throw new Error('Event end time cannot be before start time');\n    }\n\n    // Validate recurrence\n    if (data.recurring && !data.recurrenceRule) {\n      throw new Error('Recurring events must have a recurrence rule');\n    }\n\n    // Validate attendees\n    if (data.attendees && data.attendees.length > 0) {\n      data.attendees.forEach((attendee, index) => {\n        if (!attendee.email || !attendee.name) {\n          throw new Error(`Attendee at index ${index} must have email and name`);\n        }\n        // Validate email format\n        const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n        if (!emailRegex.test(attendee.email)) {\n          throw new Error(`Invalid email for attendee: ${attendee.email}`);\n        }\n      });\n    }\n\n    // Validate reminders\n    if (data.reminders && data.reminders.length > 0) {\n      data.reminders.forEach((reminder, index) => {\n        if (!reminder.method || reminder.minutesBefore == null) {\n          throw new Error(`Reminder at index ${index} must have method and minutesBefore`);\n        }\n        if (reminder.minutesBefore < 0) {\n          throw new Error('Reminder minutesBefore must be non-negative');\n        }\n      });\n    }\n\n    // Validate timezone if provided\n    if (data.timeZone) {\n      try {\n        // Test if timezone is valid by trying to use it\n        new Intl.DateTimeFormat('en-US', { timeZone: data.timeZone });\n      } catch (e) {\n        throw new Error(`Invalid timezone: ${data.timeZone}`);\n      }\n    }\n  }\n\n  /**\n   * Create a new Event instance\n   * @param {import('../../types.js').EventData} eventData - Event data object\n   * @throws {Error} If required fields are missing or invalid\n   */\n  constructor({\n    id,\n    title,\n    start,\n    end,\n    allDay = false,\n    description = '',\n    location = '',\n    color = null,\n    backgroundColor = null,\n    borderColor = null,\n    textColor = null,\n    recurring = false,\n    recurrenceRule = null,\n    timeZone = null,\n    endTimeZone = null,\n    status = 'confirmed',\n    visibility = 'public',\n    organizer = null,\n    attendees = [],\n    reminders = [],\n    categories = [],\n    attachments = [],\n    conferenceData = null,\n    metadata = {}\n  }) {\n    // Normalize and validate input\n    const normalized = Event.normalize({\n      id,\n      title,\n      start,\n      end,\n      allDay,\n      description,\n      location,\n      color,\n      backgroundColor,\n      borderColor,\n      textColor,\n      recurring,\n      recurrenceRule,\n      timeZone,\n      endTimeZone,\n      status,\n      visibility,\n      organizer,\n      attendees,\n      reminders,\n      categories,\n      attachments,\n      conferenceData,\n      metadata\n    });\n\n    // Validate normalized data\n    Event.validate(normalized);\n\n    this.id = normalized.id;\n    this.title = normalized.title;\n\n    // Initialize timezone manager\n    this._timezoneManager = new TimezoneManager();\n\n    // Timezone handling\n    // Store the timezone the event was created in (wall-clock time)\n    this.timeZone = normalized.timeZone || this._timezoneManager.getSystemTimezone();\n    this.endTimeZone = normalized.endTimeZone || this.timeZone; // Different end timezone for flights etc.\n\n    // Store dates as provided (wall-clock time in event timezone)\n    this.start = normalized.start;\n    this.end = normalized.end;\n\n    // Store UTC versions for efficient querying and comparison\n    this.startUTC = this._timezoneManager.toUTC(this.start, this.timeZone);\n    this.endUTC = this._timezoneManager.toUTC(this.end, this.endTimeZone);\n\n    this.allDay = normalized.allDay;\n    this.description = normalized.description;\n    this.location = normalized.location;\n\n    // Styling\n    this.color = normalized.color;\n    this.backgroundColor = normalized.backgroundColor;\n    this.borderColor = normalized.borderColor;\n    this.textColor = normalized.textColor;\n\n    // Recurrence\n    this.recurring = normalized.recurring;\n    this.recurrenceRule = normalized.recurrenceRule;\n\n    // Store original timezone from system if not provided\n    this._originalTimeZone = normalized.timeZone || null;\n\n    // Event status and visibility\n    this.status = normalized.status;\n    this.visibility = normalized.visibility;\n\n    // People\n    this.organizer = normalized.organizer;\n    this.attendees = [...normalized.attendees];\n\n    // Reminders\n    this.reminders = [...normalized.reminders];\n\n    // Categories/Tags\n    this.categories = [...normalized.categories];\n\n    // Attachments\n    this.attachments = [...normalized.attachments];\n\n    // Conference/Virtual meeting\n    this.conferenceData = normalized.conferenceData;\n\n    // Custom metadata for extensibility\n    this.metadata = { ...normalized.metadata };\n\n    // Computed properties cache\n    this._cache = {};\n\n    // Validate complex properties\n    this._validateAttendees();\n    this._validateReminders();\n  }\n\n  /**\n   * Get event duration in milliseconds\n   * @returns {number} Duration in milliseconds\n   */\n  get duration() {\n    if (!this._cache.duration) {\n      // Use UTC times for accurate duration calculation\n      this._cache.duration = this.endUTC.getTime() - this.startUTC.getTime();\n    }\n    return this._cache.duration;\n  }\n\n  /**\n   * Get start date in a specific timezone\n   * @param {string} timezone - Target timezone\n   * @returns {Date} Start date in specified timezone\n   */\n  getStartInTimezone(timezone) {\n    if (timezone === this.timeZone) {\n      return new Date(this.start);\n    }\n    return this._timezoneManager.fromUTC(this.startUTC, timezone);\n  }\n\n  /**\n   * Get end date in a specific timezone\n   * @param {string} timezone - Target timezone\n   * @returns {Date} End date in specified timezone\n   */\n  getEndInTimezone(timezone) {\n    if (timezone === this.endTimeZone) {\n      return new Date(this.end);\n    }\n    return this._timezoneManager.fromUTC(this.endUTC, timezone);\n  }\n\n  /**\n   * Update event times preserving the timezone\n   * @param {Date} start - New start date\n   * @param {Date} end - New end date\n   * @param {string} [timezone] - Timezone for the new dates\n   */\n  updateTimes(start, end, timezone) {\n    const tz = timezone || this.timeZone;\n\n    this.start = start instanceof Date ? start : new Date(start);\n    this.end = end instanceof Date ? end : new Date(end);\n\n    if (timezone) {\n      this.timeZone = timezone;\n      this.endTimeZone = timezone;\n    }\n\n    // Update UTC versions\n    this.startUTC = this._timezoneManager.toUTC(this.start, this.timeZone);\n    this.endUTC = this._timezoneManager.toUTC(this.end, this.endTimeZone);\n\n    // Clear cache\n    this._cache = {};\n\n    // Validate\n    if (this.endUTC < this.startUTC) {\n      throw new Error('Event end time cannot be before start time');\n    }\n  }\n\n  /**\n   * Get event duration in minutes\n   * @returns {number} Duration in minutes\n   */\n  get durationMinutes() {\n    return Math.floor(this.duration / (1000 * 60));\n  }\n\n  /**\n   * Get event duration in hours\n   * @returns {number} Duration in hours\n   */\n  get durationHours() {\n    return this.duration / (1000 * 60 * 60);\n  }\n\n  /**\n   * Check if this is a multi-day event\n   * @returns {boolean} True if event spans multiple days\n   */\n  get isMultiDay() {\n    if (!this._cache.hasOwnProperty('isMultiDay')) {\n      const startDay = this.start.toDateString();\n      const endDay = this.end.toDateString();\n      this._cache.isMultiDay = startDay !== endDay;\n    }\n    return this._cache.isMultiDay;\n  }\n\n  /**\n   * Check if event is recurring\n   * @returns {boolean} True if event is recurring\n   */\n  isRecurring() {\n    return this.recurring && this.recurrenceRule !== null;\n  }\n\n  /**\n   * Check if event occurs on a specific date\n   * @param {Date|string} date - The date to check\n   * @returns {boolean} True if event occurs on the given date\n   */\n  occursOn(date) {\n    if (!(date instanceof Date)) {\n      date = new Date(date);\n    }\n\n    const dateString = date.toDateString();\n    const startString = this.start.toDateString();\n    const endString = this.end.toDateString();\n\n    // For all-day events, check if date falls within range\n    if (this.allDay) {\n      return date >= new Date(startString) && date <= new Date(endString);\n    }\n\n    // For timed events, check if any part of the event occurs on this date\n    if (this.isMultiDay) {\n      // Multi-day event: check if date is within range\n      const dayStart = new Date(dateString);\n      const dayEnd = new Date(dateString);\n      dayEnd.setHours(23, 59, 59, 999);\n\n      return this.start <= dayEnd && this.end >= dayStart;\n    } else {\n      // Single day event: check if it's on the same day\n      return startString === dateString;\n    }\n  }\n\n  /**\n   * Check if this event overlaps with another event\n   * @param {Event|{start: Date, end: Date}} otherEvent - The other event or time range to check\n   * @returns {boolean} True if events overlap\n   * @throws {Error} If otherEvent is not an Event instance or doesn't have start/end\n   */\n  overlaps(otherEvent) {\n    if (otherEvent instanceof Event) {\n      // Events don't overlap if one ends before the other starts\n      return !(this.end <= otherEvent.start || this.start >= otherEvent.end);\n    } else if (otherEvent && otherEvent.start && otherEvent.end) {\n      // Allow checking against time ranges\n      return !(this.end <= otherEvent.start || this.start >= otherEvent.end);\n    } else {\n      throw new Error('Parameter must be an Event instance or have start/end properties');\n    }\n  }\n\n  /**\n   * Check if event contains a specific datetime\n   * @param {Date|string} datetime - The datetime to check\n   * @returns {boolean} True if the datetime falls within the event\n   */\n  contains(datetime) {\n    if (!(datetime instanceof Date)) {\n      datetime = new Date(datetime);\n    }\n    return datetime >= this.start && datetime <= this.end;\n  }\n\n  /**\n   * Clone the event with optional updates\n   * @param {Partial<import('../../types.js').EventData>} [updates={}] - Properties to update in the clone\n   * @returns {Event} New Event instance with updated properties\n   */\n  clone(updates = {}) {\n    return new Event({\n      id: this.id,\n      title: this.title,\n      start: new Date(this.start),\n      end: new Date(this.end),\n      allDay: this.allDay,\n      description: this.description,\n      location: this.location,\n      color: this.color,\n      backgroundColor: this.backgroundColor,\n      borderColor: this.borderColor,\n      textColor: this.textColor,\n      recurring: this.recurring,\n      recurrenceRule: this.recurrenceRule,\n      timeZone: this.timeZone,\n      status: this.status,\n      visibility: this.visibility,\n      organizer: this.organizer ? { ...this.organizer } : null,\n      attendees: this.attendees.map(a => ({ ...a })),\n      reminders: this.reminders.map(r => ({ ...r })),\n      categories: [...this.categories],\n      attachments: this.attachments.map(a => ({ ...a })),\n      conferenceData: this.conferenceData ? { ...this.conferenceData } : null,\n      metadata: { ...this.metadata },\n      ...updates\n    });\n  }\n\n  /**\n   * Convert event to plain object\n   * @returns {import('../../types.js').EventData} Plain object representation of the event\n   */\n  toObject() {\n    return {\n      id: this.id,\n      title: this.title,\n      start: this.start.toISOString(),\n      end: this.end.toISOString(),\n      allDay: this.allDay,\n      description: this.description,\n      location: this.location,\n      color: this.color,\n      backgroundColor: this.backgroundColor,\n      borderColor: this.borderColor,\n      textColor: this.textColor,\n      recurring: this.recurring,\n      recurrenceRule: this.recurrenceRule,\n      timeZone: this.timeZone,\n      status: this.status,\n      visibility: this.visibility,\n      organizer: this.organizer,\n      attendees: this.attendees,\n      reminders: this.reminders,\n      categories: this.categories,\n      attachments: this.attachments,\n      conferenceData: this.conferenceData,\n      metadata: { ...this.metadata }\n    };\n  }\n\n  /**\n   * Create Event from plain object\n   * @param {import('../../types.js').EventData} obj - Plain object with event properties\n   * @returns {Event} New Event instance\n   */\n  static fromObject(obj) {\n    return new Event(obj);\n  }\n\n  /**\n   * Compare events for equality\n   * @param {Event} other - The other event\n   * @returns {boolean} True if events are equal\n   */\n  equals(other) {\n    if (!(other instanceof Event)) return false;\n\n    return (\n      this.id === other.id &&\n      this.title === other.title &&\n      this.start.getTime() === other.start.getTime() &&\n      this.end.getTime() === other.end.getTime() &&\n      this.allDay === other.allDay &&\n      this.description === other.description &&\n      this.location === other.location &&\n      this.recurring === other.recurring &&\n      this.recurrenceRule === other.recurrenceRule &&\n      this.status === other.status\n    );\n  }\n\n  // ============ Attendee Management Methods ============\n\n  /**\n   * Add an attendee to the event\n   * @param {import('../../types.js').Attendee} attendee - Attendee to add\n   * @returns {boolean} True if attendee was added, false if already exists\n   */\n  addAttendee(attendee) {\n    if (!attendee || !attendee.email) {\n      throw new Error('Attendee must have an email');\n    }\n\n    // Check if attendee already exists\n    if (this.hasAttendee(attendee.email)) {\n      return false;\n    }\n\n    // Generate ID if not provided\n    if (!attendee.id) {\n      attendee.id = `attendee_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n\n    // Set defaults\n    attendee.responseStatus = attendee.responseStatus || 'needs-action';\n    attendee.role = attendee.role || 'required';\n\n    this.attendees.push(attendee);\n    return true;\n  }\n\n  /**\n   * Remove an attendee from the event\n   * @param {string} emailOrId - Email or ID of the attendee to remove\n   * @returns {boolean} True if attendee was removed\n   */\n  removeAttendee(emailOrId) {\n    const index = this.attendees.findIndex(\n      a => a.email === emailOrId || a.id === emailOrId\n    );\n\n    if (index !== -1) {\n      this.attendees.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Update an attendee's response status\n   * @param {string} email - Attendee's email\n   * @param {import('../../types.js').AttendeeResponseStatus} responseStatus - New response status\n   * @returns {boolean} True if attendee was updated\n   */\n  updateAttendeeResponse(email, responseStatus) {\n    const attendee = this.getAttendee(email);\n    if (attendee) {\n      attendee.responseStatus = responseStatus;\n      attendee.responseTime = new Date();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Get an attendee by email\n   * @param {string} email - Attendee's email\n   * @returns {import('../../types.js').Attendee|null} The attendee or null\n   */\n  getAttendee(email) {\n    return this.attendees.find(a => a.email === email) || null;\n  }\n\n  /**\n   * Check if an attendee exists\n   * @param {string} email - Attendee's email\n   * @returns {boolean} True if attendee exists\n   */\n  hasAttendee(email) {\n    return this.attendees.some(a => a.email === email);\n  }\n\n  /**\n   * Get attendees by response status\n   * @param {import('../../types.js').AttendeeResponseStatus} status - Response status to filter by\n   * @returns {import('../../types.js').Attendee[]} Filtered attendees\n   */\n  getAttendeesByStatus(status) {\n    return this.attendees.filter(a => a.responseStatus === status);\n  }\n\n  /**\n   * Get count of attendees by response status\n   * @returns {Object.<string, number>} Count by status\n   */\n  getAttendeeCounts() {\n    return this.attendees.reduce((counts, attendee) => {\n      const status = attendee.responseStatus || 'needs-action';\n      counts[status] = (counts[status] || 0) + 1;\n      return counts;\n    }, {});\n  }\n\n  // ============ Reminder Management Methods ============\n\n  /**\n   * Add a reminder to the event\n   * @param {import('../../types.js').Reminder} reminder - Reminder to add\n   * @returns {boolean} True if reminder was added\n   */\n  addReminder(reminder) {\n    if (!reminder || typeof reminder.minutesBefore !== 'number') {\n      throw new Error('Reminder must have minutesBefore property');\n    }\n\n    // Generate ID if not provided\n    if (!reminder.id) {\n      reminder.id = `reminder_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n\n    // Set defaults\n    reminder.method = reminder.method || 'popup';\n    reminder.enabled = reminder.enabled !== false;\n\n    // Check for duplicate\n    const duplicate = this.reminders.some(\n      r => r.method === reminder.method && r.minutesBefore === reminder.minutesBefore\n    );\n\n    if (duplicate) {\n      return false;\n    }\n\n    this.reminders.push(reminder);\n    return true;\n  }\n\n  /**\n   * Remove a reminder from the event\n   * @param {string} reminderId - ID of the reminder to remove\n   * @returns {boolean} True if reminder was removed\n   */\n  removeReminder(reminderId) {\n    const index = this.reminders.findIndex(r => r.id === reminderId);\n    if (index !== -1) {\n      this.reminders.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Get active reminders\n   * @returns {import('../../types.js').Reminder[]} Active reminders\n   */\n  getActiveReminders() {\n    return this.reminders.filter(r => r.enabled !== false);\n  }\n\n  /**\n   * Get reminder trigger times\n   * @returns {Date[]} Array of dates when reminders should trigger\n   */\n  getReminderTriggerTimes() {\n    return this.getActiveReminders().map(reminder => {\n      const triggerTime = new Date(this.start);\n      triggerTime.setMinutes(triggerTime.getMinutes() - reminder.minutesBefore);\n      return triggerTime;\n    });\n  }\n\n  // ============ Category Management Methods ============\n\n  /**\n   * Add a category to the event\n   * @param {string} category - Category to add\n   * @returns {boolean} True if category was added\n   */\n  addCategory(category) {\n    if (!category || typeof category !== 'string') {\n      throw new Error('Category must be a non-empty string');\n    }\n\n    const normalizedCategory = category.trim().toLowerCase();\n    if (!this.hasCategory(normalizedCategory)) {\n      this.categories.push(normalizedCategory);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Remove a category from the event\n   * @param {string} category - Category to remove\n   * @returns {boolean} True if category was removed\n   */\n  removeCategory(category) {\n    const normalizedCategory = category.trim().toLowerCase();\n    const index = this.categories.findIndex(\n      c => c.toLowerCase() === normalizedCategory\n    );\n\n    if (index !== -1) {\n      this.categories.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Check if event has a specific category\n   * @param {string} category - Category to check\n   * @returns {boolean} True if event has the category\n   */\n  hasCategory(category) {\n    const normalizedCategory = category.trim().toLowerCase();\n    return this.categories.some(c => c.toLowerCase() === normalizedCategory);\n  }\n\n  /**\n   * Check if event has any of the specified categories\n   * @param {string[]} categories - Categories to check\n   * @returns {boolean} True if event has any of the categories\n   */\n  hasAnyCategory(categories) {\n    return categories.some(category => this.hasCategory(category));\n  }\n\n  /**\n   * Check if event has all of the specified categories\n   * @param {string[]} categories - Categories to check\n   * @returns {boolean} True if event has all of the categories\n   */\n  hasAllCategories(categories) {\n    return categories.every(category => this.hasCategory(category));\n  }\n\n  // ============ Validation Methods ============\n\n  /**\n   * Validate attendees\n   * @private\n   * @throws {Error} If attendees are invalid\n   */\n  _validateAttendees() {\n    for (const attendee of this.attendees) {\n      if (!attendee.email) {\n        throw new Error('All attendees must have an email address');\n      }\n      if (!attendee.name) {\n        attendee.name = attendee.email; // Use email as fallback name\n      }\n      if (!this._isValidEmail(attendee.email)) {\n        throw new Error(`Invalid attendee email: ${attendee.email}`);\n      }\n    }\n  }\n\n  /**\n   * Validate reminders\n   * @private\n   * @throws {Error} If reminders are invalid\n   */\n  _validateReminders() {\n    for (const reminder of this.reminders) {\n      if (typeof reminder.minutesBefore !== 'number' || reminder.minutesBefore < 0) {\n        throw new Error('Reminder minutesBefore must be a positive number');\n      }\n\n      const validMethods = ['email', 'popup', 'sms'];\n      if (!validMethods.includes(reminder.method)) {\n        throw new Error(`Invalid reminder method: ${reminder.method}`);\n      }\n    }\n  }\n\n  /**\n   * Validate email address\n   * @private\n   * @param {string} email - Email to validate\n   * @returns {boolean} True if email is valid\n   */\n  _isValidEmail(email) {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n  }\n\n  // ============ Enhanced Getters ============\n\n  /**\n   * Check if the event is cancelled\n   * @returns {boolean} True if event is cancelled\n   */\n  get isCancelled() {\n    return this.status === 'cancelled';\n  }\n\n  /**\n   * Check if the event is tentative\n   * @returns {boolean} True if event is tentative\n   */\n  get isTentative() {\n    return this.status === 'tentative';\n  }\n\n  /**\n   * Check if the event is confirmed\n   * @returns {boolean} True if event is confirmed\n   */\n  get isConfirmed() {\n    return this.status === 'confirmed';\n  }\n\n  /**\n   * Check if the event is private\n   * @returns {boolean} True if event is private\n   */\n  get isPrivate() {\n    return this.visibility === 'private';\n  }\n\n  /**\n   * Check if the event is public\n   * @returns {boolean} True if event is public\n   */\n  get isPublic() {\n    return this.visibility === 'public';\n  }\n\n  /**\n   * Check if the event has attendees\n   * @returns {boolean} True if event has attendees\n   */\n  get hasAttendees() {\n    return this.attendees.length > 0;\n  }\n\n  /**\n   * Check if the event has reminders\n   * @returns {boolean} True if event has reminders\n   */\n  get hasReminders() {\n    return this.reminders.length > 0;\n  }\n\n  /**\n   * Check if the event is a meeting (has attendees or conference data)\n   * @returns {boolean} True if event is a meeting\n   */\n  get isMeeting() {\n    return this.hasAttendees || this.conferenceData !== null;\n  }\n\n  /**\n   * Check if the event is virtual (has conference data)\n   * @returns {boolean} True if event is virtual\n   */\n  get isVirtual() {\n    return this.conferenceData !== null;\n  }\n}","/**\n * DateUtils - Date manipulation utilities\n * Pure functions, no external dependencies\n * Locker Service compatible\n */\nexport class DateUtils {\n  /**\n   * Get the start of a day\n   * @param {Date} date - The date\n   * @returns {Date}\n   */\n  static startOfDay(date) {\n    const result = new Date(date);\n    result.setHours(0, 0, 0, 0);\n    return result;\n  }\n\n  /**\n   * Get the end of a day\n   * @param {Date} date - The date\n   * @returns {Date}\n   */\n  static endOfDay(date) {\n    const result = new Date(date);\n    result.setHours(23, 59, 59, 999);\n    return result;\n  }\n\n  /**\n   * Get the start of a week\n   * @param {Date} date - The date\n   * @param {number} [weekStartsOn=0] - 0 = Sunday, 1 = Monday, etc.\n   * @returns {Date} Start of the week\n   */\n  static startOfWeek(date, weekStartsOn = 0) {\n    const result = new Date(date);\n    const day = result.getDay();\n    const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;\n\n    // Use setTime to handle month/year boundaries correctly\n    result.setTime(result.getTime() - (diff * 24 * 60 * 60 * 1000));\n    result.setHours(0, 0, 0, 0);\n    return result;\n  }\n\n  /**\n   * Get the end of a week\n   * @param {Date} date - The date\n   * @param {number} weekStartsOn - 0 = Sunday, 1 = Monday, etc.\n   * @returns {Date}\n   */\n  static endOfWeek(date, weekStartsOn = 0) {\n    const result = DateUtils.startOfWeek(date, weekStartsOn);\n    // Use setTime to handle month/year boundaries correctly\n    result.setTime(result.getTime() + (6 * 24 * 60 * 60 * 1000));\n    result.setHours(23, 59, 59, 999);\n    return result;\n  }\n\n  /**\n   * Get the start of a month\n   * @param {Date} date - The date\n   * @returns {Date}\n   */\n  static startOfMonth(date) {\n    return new Date(date.getFullYear(), date.getMonth(), 1, 0, 0, 0, 0);\n  }\n\n  /**\n   * Get the end of a month\n   * @param {Date} date - The date\n   * @returns {Date}\n   */\n  static endOfMonth(date) {\n    return new Date(date.getFullYear(), date.getMonth() + 1, 0, 23, 59, 59, 999);\n  }\n\n  /**\n   * Get the start of a year\n   * @param {Date} date - The date\n   * @returns {Date}\n   */\n  static startOfYear(date) {\n    return new Date(date.getFullYear(), 0, 1, 0, 0, 0, 0);\n  }\n\n  /**\n   * Get the end of a year\n   * @param {Date} date - The date\n   * @returns {Date}\n   */\n  static endOfYear(date) {\n    return new Date(date.getFullYear(), 11, 31, 23, 59, 59, 999);\n  }\n\n  /**\n   * Add days to a date\n   * @param {Date} date - The date\n   * @param {number} days - Number of days to add (can be negative)\n   * @returns {Date}\n   */\n  static addDays(date, days) {\n    const result = new Date(date);\n    // Use setTime to handle month/year boundaries correctly\n    result.setTime(result.getTime() + (days * 24 * 60 * 60 * 1000));\n    return result;\n  }\n\n  /**\n   * Add weeks to a date\n   * @param {Date} date - The date\n   * @param {number} weeks - Number of weeks to add\n   * @returns {Date}\n   */\n  static addWeeks(date, weeks) {\n    return DateUtils.addDays(date, weeks * 7);\n  }\n\n  /**\n   * Add months to a date\n   * @param {Date} date - The date\n   * @param {number} months - Number of months to add\n   * @returns {Date}\n   */\n  static addMonths(date, months) {\n    const result = new Date(date);\n    const dayOfMonth = result.getDate();\n    result.setMonth(result.getMonth() + months);\n\n    // Handle edge case where day doesn't exist in new month\n    if (result.getDate() !== dayOfMonth) {\n      result.setDate(0); // Go to last day of previous month\n    }\n\n    return result;\n  }\n\n  /**\n   * Add years to a date\n   * @param {Date} date - The date\n   * @param {number} years - Number of years to add\n   * @returns {Date}\n   */\n  static addYears(date, years) {\n    const result = new Date(date);\n    result.setFullYear(result.getFullYear() + years);\n    return result;\n  }\n\n  /**\n   * Check if a date is today\n   * @param {Date} date - The date to check\n   * @returns {boolean}\n   */\n  static isToday(date) {\n    const today = new Date();\n    return date.toDateString() === today.toDateString();\n  }\n\n  /**\n   * Check if a date is in the past\n   * @param {Date} date - The date to check\n   * @returns {boolean}\n   */\n  static isPast(date) {\n    return date < new Date();\n  }\n\n  /**\n   * Check if a date is in the future\n   * @param {Date} date - The date to check\n   * @returns {boolean}\n   */\n  static isFuture(date) {\n    return date > new Date();\n  }\n\n  /**\n   * Check if two dates are on the same day\n   * @param {Date} date1 - First date\n   * @param {Date} date2 - Second date\n   * @returns {boolean}\n   */\n  static isSameDay(date1, date2) {\n    return date1.getFullYear() === date2.getFullYear() &&\n           date1.getMonth() === date2.getMonth() &&\n           date1.getDate() === date2.getDate();\n  }\n\n  /**\n   * Check if two dates are in the same week\n   * @param {Date} date1 - First date\n   * @param {Date} date2 - Second date\n   * @param {number} weekStartsOn - 0 = Sunday, 1 = Monday, etc.\n   * @returns {boolean}\n   */\n  static isSameWeek(date1, date2, weekStartsOn = 0) {\n    const week1Start = DateUtils.startOfWeek(date1, weekStartsOn);\n    const week2Start = DateUtils.startOfWeek(date2, weekStartsOn);\n    return week1Start.toDateString() === week2Start.toDateString();\n  }\n\n  /**\n   * Check if two dates are in the same month\n   * @param {Date} date1 - First date\n   * @param {Date} date2 - Second date\n   * @returns {boolean}\n   */\n  static isSameMonth(date1, date2) {\n    return date1.getFullYear() === date2.getFullYear() &&\n           date1.getMonth() === date2.getMonth();\n  }\n\n  /**\n   * Check if two dates are in the same year\n   * @param {Date} date1 - First date\n   * @param {Date} date2 - Second date\n   * @returns {boolean}\n   */\n  static isSameYear(date1, date2) {\n    return date1.getFullYear() === date2.getFullYear();\n  }\n\n  /**\n   * Get the difference in days between two dates\n   * @param {Date} date1 - First date\n   * @param {Date} date2 - Second date\n   * @returns {number}\n   */\n  static differenceInDays(date1, date2) {\n    const diff = date1.getTime() - date2.getTime();\n    return Math.floor(diff / (1000 * 60 * 60 * 24));\n  }\n\n  /**\n   * Get the difference in weeks between two dates\n   * @param {Date} date1 - First date\n   * @param {Date} date2 - Second date\n   * @returns {number}\n   */\n  static differenceInWeeks(date1, date2) {\n    return Math.floor(DateUtils.differenceInDays(date1, date2) / 7);\n  }\n\n  /**\n   * Get the difference in months between two dates\n   * @param {Date} date1 - First date\n   * @param {Date} date2 - Second date\n   * @returns {number}\n   */\n  static differenceInMonths(date1, date2) {\n    const yearDiff = date1.getFullYear() - date2.getFullYear();\n    const monthDiff = date1.getMonth() - date2.getMonth();\n    return yearDiff * 12 + monthDiff;\n  }\n\n  /**\n   * Get the week number of a date\n   * @param {Date} date - The date\n   * @returns {number}\n   */\n  static getWeekNumber(date) {\n    const firstDayOfYear = new Date(date.getFullYear(), 0, 1);\n    const pastDaysOfYear = (date - firstDayOfYear) / 86400000;\n    return Math.ceil((pastDaysOfYear + firstDayOfYear.getDay() + 1) / 7);\n  }\n\n  /**\n   * Get the day of week for a date\n   * @param {Date} date - The date\n   * @param {number} weekStartsOn - 0 = Sunday, 1 = Monday, etc.\n   * @returns {number} 0-6 where 0 is the first day of the week\n   */\n  static getDayOfWeek(date, weekStartsOn = 0) {\n    const day = date.getDay();\n    return (day - weekStartsOn + 7) % 7;\n  }\n\n  /**\n   * Get days in a month\n   * @param {Date} date - Any date in the month\n   * @returns {number}\n   */\n  static getDaysInMonth(date) {\n    return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();\n  }\n\n  /**\n   * Format a date using Intl.DateTimeFormat\n   * @param {Date} date - The date to format\n   * @param {string} locale - The locale\n   * @param {Object} options - Intl.DateTimeFormat options\n   * @returns {string}\n   */\n  static format(date, locale = 'en-US', options = {}) {\n    return new Intl.DateTimeFormat(locale, options).format(date);\n  }\n\n  /**\n   * Get month name\n   * @param {Date} date - The date\n   * @param {string} locale - The locale\n   * @param {string} format - 'long', 'short', or 'narrow'\n   * @returns {string}\n   */\n  static getMonthName(date, locale = 'en-US', format = 'long') {\n    return DateUtils.format(date, locale, { month: format });\n  }\n\n  /**\n   * Get day name\n   * @param {Date} date - The date\n   * @param {string} locale - The locale\n   * @param {string} format - 'long', 'short', or 'narrow'\n   * @returns {string}\n   */\n  static getDayName(date, locale = 'en-US', format = 'long') {\n    return DateUtils.format(date, locale, { weekday: format });\n  }\n\n  /**\n   * Format time\n   * @param {Date} date - The date\n   * @param {string} locale - The locale\n   * @param {boolean} use24Hour - Use 24-hour format\n   * @returns {string}\n   */\n  static formatTime(date, locale = 'en-US', use24Hour = false) {\n    return DateUtils.format(date, locale, {\n      hour: 'numeric',\n      minute: '2-digit',\n      hour12: !use24Hour\n    });\n  }\n\n  /**\n   * Parse a time string (HH:MM) to hours and minutes\n   * @param {string} timeString - Time string like \"09:30\"\n   * @returns {{hours: number, minutes: number}}\n   */\n  static parseTime(timeString) {\n    const [hours, minutes] = timeString.split(':').map(Number);\n    return { hours, minutes };\n  }\n\n  /**\n   * Set time on a date\n   * @param {Date} date - The date\n   * @param {string} timeString - Time string like \"09:30\"\n   * @returns {Date}\n   */\n  static setTime(date, timeString) {\n    const result = new Date(date);\n    const { hours, minutes } = DateUtils.parseTime(timeString);\n    result.setHours(hours, minutes, 0, 0);\n    return result;\n  }\n\n  /**\n   * Check if a year is a leap year\n   * @param {number} year - The year\n   * @returns {boolean}\n   */\n  static isLeapYear(year) {\n    return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);\n  }\n\n  /**\n   * Get an array of dates between start and end\n   * @param {Date} start - Start date\n   * @param {Date} end - End date\n   * @returns {Date[]}\n   */\n  static getDateRange(start, end) {\n    const dates = [];\n    const current = new Date(start);\n    const endTime = end.getTime();\n\n    while (current.getTime() <= endTime) {\n      dates.push(new Date(current));\n      // Use setTime to handle month/year boundaries correctly\n      current.setTime(current.getTime() + (24 * 60 * 60 * 1000));\n    }\n\n    return dates;\n  }\n\n  /**\n   * Clone a date\n   * @param {Date} date - The date to clone\n   * @returns {Date}\n   */\n  static clone(date) {\n    return new Date(date);\n  }\n\n  /**\n   * Validate if a value is a valid date\n   * @param {*} value - Value to check\n   * @returns {boolean}\n   */\n  static isValidDate(value) {\n    return value instanceof Date && !isNaN(value.getTime());\n  }\n\n  /**\n   * Convert a date to a specific timezone\n   * @param {Date} date - The date to convert\n   * @param {string} timeZone - IANA timezone string (e.g., 'America/New_York')\n   * @returns {Date} - Date object adjusted for timezone\n   */\n  static toTimeZone(date, timeZone) {\n    // Get the date string in the target timezone\n    const formatter = new Intl.DateTimeFormat('en-US', {\n      timeZone,\n      year: 'numeric',\n      month: '2-digit',\n      day: '2-digit',\n      hour: '2-digit',\n      minute: '2-digit',\n      second: '2-digit',\n      hour12: false\n    });\n\n    const parts = formatter.formatToParts(date);\n    const dateObj = {};\n    parts.forEach(part => {\n      if (part.type !== 'literal') {\n        dateObj[part.type] = part.value;\n      }\n    });\n\n    // Create new date in the target timezone\n    return new Date(\n      `${dateObj.year}-${dateObj.month}-${dateObj.day}T${dateObj.hour}:${dateObj.minute}:${dateObj.second}`\n    );\n  }\n\n  /**\n   * Get timezone offset in minutes for a date\n   * @param {Date} date - The date\n   * @param {string} timeZone - IANA timezone string\n   * @returns {number} - Offset in minutes\n   */\n  static getTimezoneOffset(date, timeZone) {\n    const utcDate = new Date(date.toLocaleString('en-US', { timeZone: 'UTC' }));\n    const tzDate = new Date(date.toLocaleString('en-US', { timeZone }));\n    return (utcDate.getTime() - tzDate.getTime()) / 60000;\n  }\n\n  /**\n   * Check if DST is in effect for a date in a timezone\n   * @param {Date} date - The date to check\n   * @param {string} timeZone - IANA timezone string\n   * @returns {boolean}\n   */\n  static isDST(date, timeZone) {\n    const jan = new Date(date.getFullYear(), 0, 1);\n    const jul = new Date(date.getFullYear(), 6, 1);\n    const janOffset = DateUtils.getTimezoneOffset(jan, timeZone);\n    const julOffset = DateUtils.getTimezoneOffset(jul, timeZone);\n    const currentOffset = DateUtils.getTimezoneOffset(date, timeZone);\n\n    return Math.max(janOffset, julOffset) === currentOffset;\n  }\n\n  /**\n   * Add time accounting for DST transitions\n   * @param {Date} date - The date\n   * @param {number} hours - Hours to add\n   * @param {string} timeZone - IANA timezone string\n   * @returns {Date}\n   */\n  static addHoursWithDST(date, hours, timeZone) {\n    const result = new Date(date);\n    const originalOffset = DateUtils.getTimezoneOffset(date, timeZone);\n\n    // Add hours\n    result.setTime(result.getTime() + (hours * 60 * 60 * 1000));\n\n    // Check if DST transition occurred\n    const newOffset = DateUtils.getTimezoneOffset(result, timeZone);\n    if (originalOffset !== newOffset) {\n      // Adjust for DST change\n      const dstAdjustment = (newOffset - originalOffset) * 60000;\n      result.setTime(result.getTime() + dstAdjustment);\n    }\n\n    return result;\n  }\n\n  /**\n   * Create a date in a specific timezone\n   * @param {number} year\n   * @param {number} month - 0-indexed\n   * @param {number} day\n   * @param {number} hour\n   * @param {number} minute\n   * @param {number} second\n   * @param {string} timeZone - IANA timezone string\n   * @returns {Date}\n   */\n  static createInTimeZone(year, month, day, hour = 0, minute = 0, second = 0, timeZone) {\n    // Create date string in ISO format\n    const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;\n    const timeStr = `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}:${String(second).padStart(2, '0')}`;\n\n    // Use Intl API to get the UTC time for this local time in the timezone\n    const formatter = new Intl.DateTimeFormat('en-US', {\n      timeZone,\n      year: 'numeric',\n      month: '2-digit',\n      day: '2-digit',\n      hour: '2-digit',\n      minute: '2-digit',\n      second: '2-digit',\n      hour12: false\n    });\n\n    // Parse the local date in the target timezone\n    const localDate = new Date(`${dateStr}T${timeStr}`);\n\n    // Get offset and adjust\n    const offset = DateUtils.getTimezoneOffset(localDate, timeZone);\n    const utcTime = localDate.getTime() + (offset * 60000);\n\n    return new Date(utcTime);\n  }\n}","import { DateUtils } from '../calendar/DateUtils.js';\nimport { TimezoneManager } from '../timezone/TimezoneManager.js';\n\n/**\n * RecurrenceEngine - Handles expansion of recurring events\n * Supports a subset of RFC 5545 (iCalendar) RRULE specification\n */\nexport class RecurrenceEngine {\n  /**\n   * Expand a recurring event into individual occurrences\n   * @param {import('./Event.js').Event} event - The recurring event\n   * @param {Date} rangeStart - Start of the expansion range\n   * @param {Date} rangeEnd - End of the expansion range\n   * @param {number} [maxOccurrences=365] - Maximum number of occurrences to generate\n   * @param {string} [timezone] - Timezone for expansion (important for DST)\n   * @returns {import('../../types.js').EventOccurrence[]} Array of occurrence objects with start/end dates\n   */\n  static expandEvent(event, rangeStart, rangeEnd, maxOccurrences = 365, timezone = null) {\n    if (!event.recurring || !event.recurrenceRule) {\n      return [{ start: event.start, end: event.end, timezone: event.timeZone }];\n    }\n\n    const rule = this.parseRule(event.recurrenceRule);\n    const occurrences = [];\n    const duration = event.end - event.start;\n    const eventTimezone = timezone || event.timeZone || 'UTC';\n    const tzManager = new TimezoneManager();\n\n    // Work in event's timezone for accurate recurrence calculation\n    let currentDate = new Date(event.start);\n    let count = 0;\n\n    // If UNTIL is specified, use it as the range end\n    if (rule.until && rule.until < rangeEnd) {\n      rangeEnd = rule.until;\n    }\n\n    // Track DST transitions for proper timezone handling\n    let lastOffset = tzManager.getTimezoneOffset(currentDate, eventTimezone);\n\n    while (currentDate <= rangeEnd && count < maxOccurrences) {\n      // Check if this occurrence is within the range\n      if (currentDate >= rangeStart) {\n        const occurrenceStart = new Date(currentDate);\n        const occurrenceEnd = new Date(currentDate.getTime() + duration);\n\n        // Handle DST transitions\n        const currentOffset = tzManager.getTimezoneOffset(occurrenceStart, eventTimezone);\n        if (currentOffset !== lastOffset) {\n          // Adjust for DST change\n          const offsetDiff = lastOffset - currentOffset;\n          occurrenceStart.setMinutes(occurrenceStart.getMinutes() + offsetDiff);\n          occurrenceEnd.setMinutes(occurrenceEnd.getMinutes() + offsetDiff);\n        }\n        lastOffset = currentOffset;\n\n        // Apply exceptions if any\n        if (!this.isException(occurrenceStart, rule, event.id)) {\n          occurrences.push({\n            start: occurrenceStart,\n            end: occurrenceEnd,\n            recurringEventId: event.id,\n            timezone: eventTimezone,\n            originalStart: event.start\n          });\n        }\n      }\n\n      // Calculate next occurrence\n      currentDate = this.getNextOccurrence(currentDate, rule, eventTimezone);\n      count++;\n\n      // Check COUNT limit\n      if (rule.count && count >= rule.count) {\n        break;\n      }\n    }\n\n    return occurrences;\n  }\n\n  /**\n   * Parse an RRULE string into a rule object\n   * @param {string|import('../../types.js').RecurrenceRule} ruleString - RRULE string (e.g., \"FREQ=DAILY;INTERVAL=1;COUNT=10\") or rule object\n   * @returns {import('../../types.js').RecurrenceRule} Parsed rule object\n   */\n  static parseRule(ruleString) {\n    const rule = {\n      freq: null,\n      interval: 1,\n      count: null,\n      until: null,\n      byDay: [],\n      byMonthDay: [],\n      byMonth: [],\n      bySetPos: [],\n      exceptions: []\n    };\n\n    if (typeof ruleString === 'object') {\n      return { ...rule, ...ruleString };\n    }\n\n    const parts = ruleString.split(';');\n    parts.forEach(part => {\n      const [key, value] = part.split('=');\n      switch (key.toUpperCase()) {\n        case 'FREQ':\n          rule.freq = value.toUpperCase();\n          break;\n        case 'INTERVAL':\n          rule.interval = parseInt(value, 10);\n          break;\n        case 'COUNT':\n          rule.count = parseInt(value, 10);\n          break;\n        case 'UNTIL':\n          rule.until = this.parseDate(value);\n          break;\n        case 'BYDAY':\n          rule.byDay = value.split(',');\n          break;\n        case 'BYMONTHDAY':\n          rule.byMonthDay = value.split(',').map(d => parseInt(d, 10));\n          break;\n        case 'BYMONTH':\n          rule.byMonth = value.split(',').map(m => parseInt(m, 10));\n          break;\n        case 'BYSETPOS':\n          rule.bySetPos = value.split(',').map(p => parseInt(p, 10));\n          break;\n      }\n    });\n\n    return rule;\n  }\n\n  /**\n   * Calculate the next occurrence based on the rule\n   * @param {Date} currentDate - Current occurrence date\n   * @param {Object} rule - Recurrence rule object\n   * @param {string} [timezone] - Timezone for calculation\n   * @returns {Date} Next occurrence date\n   */\n  static getNextOccurrence(currentDate, rule, timezone = 'UTC') {\n    const next = new Date(currentDate);\n\n    switch (rule.freq) {\n      case 'DAILY':\n        next.setDate(next.getDate() + rule.interval);\n        break;\n\n      case 'WEEKLY':\n        if (rule.byDay && rule.byDay.length > 0) {\n          // Find next day that matches byDay\n          next.setDate(next.getDate() + 1);\n          while (!this.matchesByDay(next, rule.byDay)) {\n            next.setDate(next.getDate() + 1);\n          }\n        } else {\n          // Simple weekly recurrence\n          next.setDate(next.getDate() + (7 * rule.interval));\n        }\n        break;\n\n      case 'MONTHLY':\n        if (rule.byMonthDay && rule.byMonthDay.length > 0) {\n          // Specific day(s) of month\n          const currentMonth = next.getMonth();\n          next.setMonth(currentMonth + rule.interval);\n          next.setDate(rule.byMonthDay[0]); // Use first specified day\n        } else if (rule.byDay && rule.byDay.length > 0) {\n          // Specific weekday of month (e.g., \"2nd Tuesday\")\n          next.setMonth(next.getMonth() + rule.interval);\n          this.setToWeekdayOfMonth(next, rule.byDay[0], rule.bySetPos[0] || 1);\n        } else {\n          // Same day of month\n          next.setMonth(next.getMonth() + rule.interval);\n        }\n        break;\n\n      case 'YEARLY':\n        if (rule.byMonth && rule.byMonth.length > 0) {\n          next.setFullYear(next.getFullYear() + rule.interval);\n          next.setMonth(rule.byMonth[0] - 1); // Months are 0-indexed\n        } else {\n          next.setFullYear(next.getFullYear() + rule.interval);\n        }\n        break;\n\n      default:\n        // Unsupported frequency\n        next.setTime(next.getTime() + (24 * 60 * 60 * 1000)); // Daily fallback\n    }\n\n    return next;\n  }\n\n  /**\n   * Check if a date matches the BYDAY rule\n   * @param {Date} date - Date to check\n   * @param {Array<string>} byDay - Array of day codes (e.g., ['MO', 'WE', 'FR'])\n   * @returns {boolean}\n   */\n  static matchesByDay(date, byDay) {\n    const dayMap = {\n      'SU': 0, 'MO': 1, 'TU': 2, 'WE': 3,\n      'TH': 4, 'FR': 5, 'SA': 6\n    };\n\n    const dayOfWeek = date.getDay();\n    return byDay.some(day => {\n      // Handle numbered weekdays (e.g., \"2MO\" for 2nd Monday)\n      const match = day.match(/^(-?\\d+)?([A-Z]{2})$/);\n      if (match) {\n        const weekdayCode = match[2];\n        return dayMap[weekdayCode] === dayOfWeek;\n      }\n      return false;\n    });\n  }\n\n  /**\n   * Set date to specific weekday of month\n   * @param {Date} date - Date to modify\n   * @param {string} weekday - Weekday code (e.g., 'MO', 'TU')\n   * @param {number} position - Position in month (1-5, or -1 for last)\n   */\n  static setToWeekdayOfMonth(date, weekday, position = 1) {\n    const dayMap = {\n      'SU': 0, 'MO': 1, 'TU': 2, 'WE': 3,\n      'TH': 4, 'FR': 5, 'SA': 6\n    };\n\n    // Extract weekday code if it has a number prefix\n    const match = weekday.match(/^(-?\\d+)?([A-Z]{2})$/);\n    const weekdayCode = match ? match[2] : weekday;\n    const targetDay = dayMap[weekdayCode];\n\n    date.setDate(1); // Start at first of month\n\n    // Find first occurrence of the weekday\n    while (date.getDay() !== targetDay) {\n      date.setDate(date.getDate() + 1);\n    }\n\n    // Move to the nth occurrence\n    if (position > 1) {\n      date.setDate(date.getDate() + (7 * (position - 1)));\n    } else if (position === -1) {\n      // Last occurrence of the month\n      const nextMonth = new Date(date);\n      nextMonth.setMonth(nextMonth.getMonth() + 1);\n      nextMonth.setDate(0); // Last day of current month\n\n      while (nextMonth.getDay() !== targetDay) {\n        nextMonth.setDate(nextMonth.getDate() - 1);\n      }\n      date.setTime(nextMonth.getTime());\n    }\n  }\n\n  /**\n   * Check if a date is an exception\n   * @param {Date} date - Date to check\n   * @param {Object} rule - Rule object with exceptions\n   * @param {string} [eventId] - Event ID for better exception tracking\n   * @returns {boolean}\n   */\n  static isException(date, rule, eventId = null) {\n    if (!rule.exceptions || rule.exceptions.length === 0) {\n      return false;\n    }\n\n    // Support both date-only and date-time exceptions\n    const dateStr = date.toDateString();\n    const dateTime = date.getTime();\n\n    return rule.exceptions.some(exDate => {\n      if (typeof exDate === 'object' && exDate.date) {\n        // Enhanced exception format with reason\n        const exceptionDate = exDate.date instanceof Date ? exDate.date : new Date(exDate.date);\n        if (exDate.matchTime) {\n          return Math.abs(exceptionDate.getTime() - dateTime) < 1000; // Within 1 second\n        }\n        return exceptionDate.toDateString() === dateStr;\n      } else {\n        // Simple date exception\n        const exceptionDate = exDate instanceof Date ? exDate : new Date(exDate);\n        return exceptionDate.toDateString() === dateStr;\n      }\n    });\n  }\n\n  /**\n   * Add exception dates to a recurrence rule\n   * @param {Object} rule - Recurrence rule\n   * @param {Date|Date[]} exceptions - Exception date(s) to add\n   * @param {Object} [options] - Options for exception\n   * @returns {Object} Updated rule\n   */\n  static addExceptions(rule, exceptions, options = {}) {\n    if (!rule.exceptions) {\n      rule.exceptions = [];\n    }\n\n    const exceptionArray = Array.isArray(exceptions) ? exceptions : [exceptions];\n\n    exceptionArray.forEach(date => {\n      if (options.reason || options.matchTime) {\n        rule.exceptions.push({\n          date: date,\n          reason: options.reason,\n          matchTime: options.matchTime || false\n        });\n      } else {\n        rule.exceptions.push(date);\n      }\n    });\n\n    return rule;\n  }\n\n  /**\n   * Parse date from RRULE format (YYYYMMDDTHHMMSSZ)\n   * @param {string} dateStr - Date string in RRULE format\n   * @returns {Date}\n   */\n  static parseDate(dateStr) {\n    if (dateStr.length === 8) {\n      // YYYYMMDD\n      const year = parseInt(dateStr.substr(0, 4), 10);\n      const month = parseInt(dateStr.substr(4, 2), 10) - 1;\n      const day = parseInt(dateStr.substr(6, 2), 10);\n      return new Date(year, month, day);\n    } else if (dateStr.length === 15 || dateStr.length === 16) {\n      // YYYYMMDDTHHMMSS[Z]\n      const year = parseInt(dateStr.substr(0, 4), 10);\n      const month = parseInt(dateStr.substr(4, 2), 10) - 1;\n      const day = parseInt(dateStr.substr(6, 2), 10);\n      const hour = parseInt(dateStr.substr(9, 2), 10);\n      const minute = parseInt(dateStr.substr(11, 2), 10);\n      const second = parseInt(dateStr.substr(13, 2), 10);\n\n      if (dateStr.endsWith('Z')) {\n        return new Date(Date.UTC(year, month, day, hour, minute, second));\n      } else {\n        return new Date(year, month, day, hour, minute, second);\n      }\n    }\n\n    // Fallback to standard date parsing\n    return new Date(dateStr);\n  }\n\n  /**\n   * Generate a human-readable description of the recurrence rule\n   * @param {Object|string} rule - Recurrence rule\n   * @returns {string} Human-readable description\n   */\n  static getDescription(rule) {\n    if (typeof rule === 'string') {\n      rule = this.parseRule(rule);\n    }\n\n    let description = '';\n    const interval = rule.interval || 1;\n\n    switch (rule.freq) {\n      case 'DAILY':\n        description = interval === 1 ? 'Daily' : `Every ${interval} days`;\n        break;\n      case 'WEEKLY':\n        description = interval === 1 ? 'Weekly' : `Every ${interval} weeks`;\n        if (rule.byDay && rule.byDay.length > 0) {\n          const days = rule.byDay.map(d => this.getDayName(d)).join(', ');\n          description += ` on ${days}`;\n        }\n        break;\n      case 'MONTHLY':\n        description = interval === 1 ? 'Monthly' : `Every ${interval} months`;\n        if (rule.byMonthDay && rule.byMonthDay.length > 0) {\n          description += ` on day ${rule.byMonthDay.join(', ')}`;\n        }\n        break;\n      case 'YEARLY':\n        description = interval === 1 ? 'Yearly' : `Every ${interval} years`;\n        break;\n    }\n\n    if (rule.count) {\n      description += `, ${rule.count} times`;\n    } else if (rule.until) {\n      description += `, until ${rule.until.toLocaleDateString()}`;\n    }\n\n    return description;\n  }\n\n  /**\n   * Get day name from RRULE day code\n   * @param {string} dayCode - Day code (e.g., 'MO', '2TU')\n   * @returns {string} Day name\n   */\n  static getDayName(dayCode) {\n    const dayNames = {\n      'SU': 'Sunday', 'MO': 'Monday', 'TU': 'Tuesday',\n      'WE': 'Wednesday', 'TH': 'Thursday', 'FR': 'Friday',\n      'SA': 'Saturday'\n    };\n\n    // Extract day code if it has a number prefix\n    const match = dayCode.match(/^(-?\\d+)?([A-Z]{2})$/);\n    const code = match ? match[2] : dayCode;\n    const position = match && match[1] ? parseInt(match[1], 10) : null;\n\n    let name = dayNames[code] || dayCode;\n\n    if (position) {\n      const ordinals = ['', '1st', '2nd', '3rd', '4th', '5th'];\n      const ordinal = position === -1 ? 'Last' : (ordinals[position] || `${position}th`);\n      name = `${ordinal} ${name}`;\n    }\n\n    return name;\n  }\n}","/**\n * LRU (Least Recently Used) Cache implementation\n * Provides O(1) get and put operations\n */\nexport class LRUCache {\n  /**\n   * Create a new LRU Cache\n   * @param {number} capacity - Maximum number of items in cache\n   */\n  constructor(capacity = 100) {\n    this.capacity = capacity;\n    this.cache = new Map();\n    this.hits = 0;\n    this.misses = 0;\n    this.evictions = 0;\n  }\n\n  /**\n   * Get a value from the cache\n   * @param {string} key - Cache key\n   * @returns {*} Cached value or undefined\n   */\n  get(key) {\n    if (!this.cache.has(key)) {\n      this.misses++;\n      return undefined;\n    }\n\n    // Move to end (most recently used)\n    const value = this.cache.get(key);\n    this.cache.delete(key);\n    this.cache.set(key, value);\n    this.hits++;\n    return value;\n  }\n\n  /**\n   * Put a value in the cache\n   * @param {string} key - Cache key\n   * @param {*} value - Value to cache\n   */\n  put(key, value) {\n    // Remove if exists to update position\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    } else if (this.cache.size >= this.capacity) {\n      // Remove least recently used (first item)\n      const firstKey = this.cache.keys().next().value;\n      this.cache.delete(firstKey);\n      this.evictions++;\n    }\n\n    this.cache.set(key, value);\n  }\n\n  /**\n   * Check if key exists in cache\n   * @param {string} key - Cache key\n   * @returns {boolean} True if key exists\n   */\n  has(key) {\n    return this.cache.has(key);\n  }\n\n  /**\n   * Remove a key from the cache\n   * @param {string} key - Cache key\n   * @returns {boolean} True if key was removed\n   */\n  delete(key) {\n    return this.cache.delete(key);\n  }\n\n  /**\n   * Clear all cached items\n   */\n  clear() {\n    this.cache.clear();\n    this.hits = 0;\n    this.misses = 0;\n    this.evictions = 0;\n  }\n\n  /**\n   * Get cache statistics\n   * @returns {Object} Cache stats\n   */\n  getStats() {\n    const hitRate = this.hits + this.misses > 0\n      ? (this.hits / (this.hits + this.misses) * 100).toFixed(2)\n      : 0;\n\n    return {\n      size: this.cache.size,\n      capacity: this.capacity,\n      hits: this.hits,\n      misses: this.misses,\n      evictions: this.evictions,\n      hitRate: `${hitRate}%`\n    };\n  }\n\n  /**\n   * Get all keys in order (least to most recently used)\n   * @returns {string[]} Array of keys\n   */\n  keys() {\n    return Array.from(this.cache.keys());\n  }\n\n  /**\n   * Get cache size\n   * @returns {number} Number of items in cache\n   */\n  get size() {\n    return this.cache.size;\n  }\n}","/**\n * PerformanceOptimizer - Optimizes calendar operations for large datasets\n * Includes caching, lazy loading, and batch processing\n */\n\nimport { LRUCache } from './LRUCache.js';\n\nexport class PerformanceOptimizer {\n  constructor(config = {}) {\n    // Configuration\n    this.config = {\n      enableCache: true,\n      cacheCapacity: 500,\n      maxIndexDays: 365,\n      batchSize: 100,\n      enableMetrics: true,\n      cleanupInterval: 3600000, // 1 hour in ms\n      maxIndexAge: 30 * 24 * 60 * 60 * 1000, // 30 days in ms\n      ...config\n    };\n\n    // Caches\n    this.eventCache = new LRUCache(this.config.cacheCapacity);\n    this.queryCache = new LRUCache(Math.floor(this.config.cacheCapacity / 2));\n    this.dateRangeCache = new LRUCache(Math.floor(this.config.cacheCapacity / 4));\n\n    // Lazy loading tracking\n    this.lazyIndexes = new Map(); // eventId -> Set of date strings\n    this.pendingIndexes = new Map(); // eventId -> Promise\n\n    // Batch processing\n    this.batchQueue = [];\n    this.batchTimer = null;\n    this.batchCallbacks = [];\n\n    // Performance metrics\n    this.metrics = {\n      operations: {},\n      averageTimes: {},\n      slowQueries: []\n    };\n\n    // Cleanup timer\n    this.cleanupTimer = null;\n    if (this.config.cleanupInterval > 0) {\n      this.startCleanupTimer();\n    }\n  }\n\n  /**\n   * Measure operation performance\n   * @param {string} operation - Operation name\n   * @param {Function} fn - Function to measure\n   * @returns {*} Function result\n   */\n  measure(operation, fn) {\n    if (!this.config.enableMetrics) {\n      return fn();\n    }\n\n    const start = performance.now();\n    try {\n      const result = fn();\n      const duration = performance.now() - start;\n      this.recordMetric(operation, duration);\n      return result;\n    } catch (error) {\n      const duration = performance.now() - start;\n      this.recordMetric(operation, duration, true);\n      throw error;\n    }\n  }\n\n  /**\n   * Measure async operation performance\n   * @param {string} operation - Operation name\n   * @param {Function} fn - Async function to measure\n   * @returns {Promise<*>} Function result\n   */\n  async measureAsync(operation, fn) {\n    if (!this.config.enableMetrics) {\n      return await fn();\n    }\n\n    const start = performance.now();\n    try {\n      const result = await fn();\n      const duration = performance.now() - start;\n      this.recordMetric(operation, duration);\n      return result;\n    } catch (error) {\n      const duration = performance.now() - start;\n      this.recordMetric(operation, duration, true);\n      throw error;\n    }\n  }\n\n  /**\n   * Record performance metric\n   * @private\n   */\n  recordMetric(operation, duration, isError = false) {\n    if (!this.metrics.operations[operation]) {\n      this.metrics.operations[operation] = {\n        count: 0,\n        totalTime: 0,\n        errors: 0,\n        min: Infinity,\n        max: 0\n      };\n    }\n\n    const metric = this.metrics.operations[operation];\n    metric.count++;\n    metric.totalTime += duration;\n    metric.min = Math.min(metric.min, duration);\n    metric.max = Math.max(metric.max, duration);\n\n    if (isError) {\n      metric.errors++;\n    }\n\n    // Update average\n    this.metrics.averageTimes[operation] = metric.totalTime / metric.count;\n\n    // Track slow queries\n    if (duration > 100) {\n      this.metrics.slowQueries.push({\n        operation,\n        duration,\n        timestamp: new Date(),\n        isError\n      });\n\n      // Keep only last 100 slow queries\n      if (this.metrics.slowQueries.length > 100) {\n        this.metrics.slowQueries.shift();\n      }\n    }\n  }\n\n  /**\n   * Get performance metrics\n   * @returns {Object} Performance metrics\n   */\n  getMetrics() {\n    const summary = {\n      cacheStats: {\n        event: this.eventCache.getStats(),\n        query: this.queryCache.getStats(),\n        dateRange: this.dateRangeCache.getStats()\n      },\n      operations: {},\n      slowestOperations: [],\n      recentSlowQueries: this.metrics.slowQueries.slice(-10)\n    };\n\n    // Process operations\n    for (const [op, data] of Object.entries(this.metrics.operations)) {\n      summary.operations[op] = {\n        count: data.count,\n        avgTime: `${(data.totalTime / data.count).toFixed(2)}ms`,\n        minTime: `${data.min.toFixed(2)}ms`,\n        maxTime: `${data.max.toFixed(2)}ms`,\n        totalTime: `${data.totalTime.toFixed(2)}ms`,\n        errors: data.errors,\n        errorRate: `${((data.errors / data.count) * 100).toFixed(2)}%`\n      };\n    }\n\n    // Find slowest operations\n    summary.slowestOperations = Object.entries(this.metrics.averageTimes)\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, 5)\n      .map(([op, time]) => ({\n        operation: op,\n        avgTime: `${time.toFixed(2)}ms`\n      }));\n\n    return summary;\n  }\n\n  /**\n   * Check if event should use lazy indexing\n   * @param {import('../events/Event.js').Event} event - Event to check\n   * @returns {boolean} True if should use lazy indexing\n   */\n  shouldUseLazyIndexing(event) {\n    const daySpan = Math.ceil(\n      (event.end - event.start) / (24 * 60 * 60 * 1000)\n    );\n    return daySpan > this.config.maxIndexDays;\n  }\n\n  /**\n   * Create lazy index markers for large events\n   * @param {import('../events/Event.js').Event} event - Event to index\n   * @returns {Object} Index boundaries\n   */\n  createLazyIndexMarkers(event) {\n    const markers = {\n      eventId: event.id,\n      start: event.start,\n      end: event.end,\n      indexed: new Set(),\n      pending: false\n    };\n\n    // Index first and last month only initially\n    const startMonth = new Date(event.start.getFullYear(), event.start.getMonth(), 1);\n    const endMonth = new Date(event.end.getFullYear(), event.end.getMonth(), 1);\n\n    markers.indexed.add(this.getMonthKey(startMonth));\n    if (this.getMonthKey(startMonth) !== this.getMonthKey(endMonth)) {\n      markers.indexed.add(this.getMonthKey(endMonth));\n    }\n\n    this.lazyIndexes.set(event.id, markers);\n    return markers;\n  }\n\n  /**\n   * Expand lazy index for a specific date range\n   * @param {string} eventId - Event ID\n   * @param {Date} rangeStart - Start of range to index\n   * @param {Date} rangeEnd - End of range to index\n   * @returns {Promise<Set<string>>} Indexed date strings\n   */\n  async expandLazyIndex(eventId, rangeStart, rangeEnd) {\n    const markers = this.lazyIndexes.get(eventId);\n    if (!markers) {\n      return new Set();\n    }\n\n    // Check if already pending\n    if (markers.pending) {\n      return this.pendingIndexes.get(eventId);\n    }\n\n    markers.pending = true;\n\n    const promise = new Promise((resolve) => {\n      // Simulate async indexing (in real app, could be in worker)\n      setTimeout(() => {\n        const indexed = new Set();\n        const current = new Date(rangeStart);\n\n        while (current <= rangeEnd) {\n          const dateStr = current.toDateString();\n          if (!markers.indexed.has(dateStr)) {\n            indexed.add(dateStr);\n            markers.indexed.add(dateStr);\n          }\n          current.setDate(current.getDate() + 1);\n        }\n\n        markers.pending = false;\n        this.pendingIndexes.delete(eventId);\n        resolve(indexed);\n      }, 0);\n    });\n\n    this.pendingIndexes.set(eventId, promise);\n    return promise;\n  }\n\n  /**\n   * Get month key for date\n   * @private\n   */\n  getMonthKey(date) {\n    return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;\n  }\n\n  /**\n   * Cache event with TTL\n   * @param {string} key - Cache key\n   * @param {*} value - Value to cache\n   * @param {string} cacheType - Type of cache to use\n   */\n  cache(key, value, cacheType = 'event') {\n    if (!this.config.enableCache) return;\n\n    switch (cacheType) {\n      case 'event':\n        this.eventCache.put(key, value);\n        break;\n      case 'query':\n        this.queryCache.put(key, value);\n        break;\n      case 'dateRange':\n        this.dateRangeCache.put(key, value);\n        break;\n    }\n  }\n\n  /**\n   * Get from cache\n   * @param {string} key - Cache key\n   * @param {string} cacheType - Type of cache\n   * @returns {*} Cached value or undefined\n   */\n  getFromCache(key, cacheType = 'event') {\n    if (!this.config.enableCache) return undefined;\n\n    switch (cacheType) {\n      case 'event':\n        return this.eventCache.get(key);\n      case 'query':\n        return this.queryCache.get(key);\n      case 'dateRange':\n        return this.dateRangeCache.get(key);\n      default:\n        return undefined;\n    }\n  }\n\n  /**\n   * Invalidate caches for an event\n   * @param {string} eventId - Event ID\n   */\n  invalidateEventCaches(eventId) {\n    // Remove from event cache\n    this.eventCache.delete(eventId);\n\n    // Clear query cache (conservative approach)\n    // In production, track which queries include this event\n    this.queryCache.clear();\n    this.dateRangeCache.clear();\n  }\n\n  /**\n   * Batch operation for efficiency\n   * @param {Function} operation - Operation to batch\n   * @returns {Promise} Batch result\n   */\n  batch(operation) {\n    return new Promise((resolve, reject) => {\n      this.batchQueue.push(operation);\n      this.batchCallbacks.push({ resolve, reject });\n\n      if (this.batchQueue.length >= this.config.batchSize) {\n        this.processBatch();\n      } else if (!this.batchTimer) {\n        // Process batch after 10ms if not full\n        this.batchTimer = setTimeout(() => this.processBatch(), 10);\n      }\n    });\n  }\n\n  /**\n   * Process batched operations\n   * @private\n   */\n  processBatch() {\n    if (this.batchTimer) {\n      clearTimeout(this.batchTimer);\n      this.batchTimer = null;\n    }\n\n    if (this.batchQueue.length === 0) return;\n\n    const operations = this.batchQueue.splice(0);\n    const callbacks = this.batchCallbacks.splice(0);\n\n    // Process all operations\n    const results = [];\n    const errors = [];\n\n    operations.forEach((op, index) => {\n      try {\n        results[index] = op();\n      } catch (error) {\n        errors[index] = error;\n      }\n    });\n\n    // Resolve callbacks\n    callbacks.forEach((callback, index) => {\n      if (errors[index]) {\n        callback.reject(errors[index]);\n      } else {\n        callback.resolve(results[index]);\n      }\n    });\n  }\n\n  /**\n   * Start cleanup timer for old indexes\n   * @private\n   */\n  startCleanupTimer() {\n    this.cleanupTimer = setInterval(() => {\n      this.cleanupOldIndexes();\n    }, this.config.cleanupInterval);\n  }\n\n  /**\n   * Clean up old indexes\n   * @private\n   */\n  cleanupOldIndexes() {\n    const now = Date.now();\n    const maxAge = this.config.maxIndexAge;\n\n    // Clean up lazy indexes for events that are too old\n    for (const [eventId, markers] of this.lazyIndexes) {\n      if (markers.end.getTime() < now - maxAge) {\n        this.lazyIndexes.delete(eventId);\n      }\n    }\n\n    // Clean up slow query log\n    if (this.metrics.slowQueries.length > 100) {\n      this.metrics.slowQueries = this.metrics.slowQueries.slice(-100);\n    }\n  }\n\n  /**\n   * Optimize query by checking cache first\n   * @param {string} queryKey - Unique query identifier\n   * @param {Function} queryFn - Function to execute if not cached\n   * @returns {*} Query result\n   */\n  optimizeQuery(queryKey, queryFn) {\n    // Check cache first\n    const cached = this.getFromCache(queryKey, 'query');\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    // Execute query and cache result\n    const result = this.measure(`query:${queryKey}`, queryFn);\n    this.cache(queryKey, result, 'query');\n    return result;\n  }\n\n  /**\n   * Destroy optimizer and clean up resources\n   */\n  destroy() {\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = null;\n    }\n\n    if (this.batchTimer) {\n      clearTimeout(this.batchTimer);\n      this.batchTimer = null;\n    }\n\n    this.eventCache.clear();\n    this.queryCache.clear();\n    this.dateRangeCache.clear();\n    this.lazyIndexes.clear();\n    this.pendingIndexes.clear();\n  }\n}","/**\n * ConflictDetector - Detects scheduling conflicts between events\n * Checks for time overlaps, attendee conflicts, and resource conflicts\n */\n\nimport { DateUtils } from '../calendar/DateUtils.js';\n\nexport class ConflictDetector {\n  /**\n   * Create a new ConflictDetector\n   * @param {import('../events/EventStore.js').EventStore} eventStore - Event store instance\n   */\n  constructor(eventStore) {\n    this.eventStore = eventStore;\n    this.conflictIdCounter = 0;\n  }\n\n  /**\n   * Check for conflicts for a specific event\n   * @param {import('../events/Event.js').Event|import('../../types.js').EventData} event - Event to check\n   * @param {import('../../types.js').ConflictCheckOptions} [options={}] - Check options\n   * @returns {import('../../types.js').ConflictSummary} Conflict summary\n   */\n  checkConflicts(event, options = {}) {\n    // Default options\n    const opts = {\n      checkAttendees: true,\n      checkResources: true,\n      checkLocation: true,\n      ignoreAllDay: false,\n      excludeEventIds: [],\n      includeStatuses: ['confirmed', 'tentative'],\n      bufferMinutes: 0,\n      ...options\n    };\n\n    // Ensure we have an Event object\n    if (!event.start || !event.end) {\n      throw new Error('Event must have start and end dates');\n    }\n\n    const conflicts = [];\n    const affectedEventIds = new Set();\n    const affectedAttendees = new Set();\n\n    // Get potential conflicting events in the time range\n    const searchStart = new Date(event.start.getTime() - opts.bufferMinutes * 60000);\n    const searchEnd = new Date(event.end.getTime() + opts.bufferMinutes * 60000);\n\n    const potentialConflicts = this.eventStore.getEventsInRange(searchStart, searchEnd, false)\n      .filter(e => {\n        // Exclude self\n        if (e.id === event.id) return false;\n        // Exclude specified event IDs\n        if (opts.excludeEventIds.includes(e.id)) return false;\n        // Filter by status\n        if (!opts.includeStatuses.includes(e.status)) return false;\n        // Ignore all-day events if specified\n        if (opts.ignoreAllDay && (e.allDay || event.allDay)) return false;\n        // Ignore cancelled events\n        if (e.status === 'cancelled') return false;\n        return true;\n      });\n\n    // Check each potential conflict\n    for (const conflictingEvent of potentialConflicts) {\n      const eventConflicts = this._detectEventConflicts(\n        event,\n        conflictingEvent,\n        opts\n      );\n\n      if (eventConflicts.length > 0) {\n        conflicts.push(...eventConflicts);\n        affectedEventIds.add(event.id);\n        affectedEventIds.add(conflictingEvent.id);\n\n        // Track affected attendees\n        if (event.attendees) {\n          event.attendees.forEach(a => affectedAttendees.add(a.email));\n        }\n        if (conflictingEvent.attendees) {\n          conflictingEvent.attendees.forEach(a => affectedAttendees.add(a.email));\n        }\n      }\n    }\n\n    // Build summary\n    return this._buildConflictSummary(conflicts, affectedEventIds, affectedAttendees);\n  }\n\n  /**\n   * Check for conflicts between two specific events\n   * @param {import('../events/Event.js').Event} event1 - First event\n   * @param {import('../events/Event.js').Event} event2 - Second event\n   * @param {import('../../types.js').ConflictCheckOptions} [options={}] - Check options\n   * @returns {import('../../types.js').ConflictDetails[]} Array of conflicts\n   */\n  checkEventPairConflicts(event1, event2, options = {}) {\n    const opts = {\n      checkAttendees: true,\n      checkResources: true,\n      checkLocation: true,\n      bufferMinutes: 0,\n      ...options\n    };\n\n    return this._detectEventConflicts(event1, event2, opts);\n  }\n\n  /**\n   * Get busy periods for a set of attendees\n   * @param {string[]} attendeeEmails - Attendee email addresses\n   * @param {Date} start - Start of period\n   * @param {Date} end - End of period\n   * @param {Object} [options={}] - Options\n   * @returns {Array<{start: Date, end: Date, eventIds: string[]}>} Busy periods\n   */\n  getBusyPeriods(attendeeEmails, start, end, options = {}) {\n    const opts = {\n      includeStatuses: ['confirmed', 'tentative'],\n      mergePeriods: true,\n      ...options\n    };\n\n    const busyPeriods = [];\n    const events = this.eventStore.getEventsInRange(start, end, false);\n\n    // Find events with these attendees\n    const attendeeEvents = events.filter(event => {\n      if (!opts.includeStatuses.includes(event.status)) return false;\n      if (event.status === 'cancelled') return false;\n\n      return event.attendees && event.attendees.some(attendee =>\n        attendeeEmails.includes(attendee.email)\n      );\n    });\n\n    // Convert to busy periods\n    attendeeEvents.forEach(event => {\n      busyPeriods.push({\n        start: event.start,\n        end: event.end,\n        eventIds: [event.id]\n      });\n    });\n\n    // Merge overlapping periods if requested\n    if (opts.mergePeriods && busyPeriods.length > 1) {\n      return this._mergeBusyPeriods(busyPeriods);\n    }\n\n    return busyPeriods.sort((a, b) => a.start - b.start);\n  }\n\n  /**\n   * Get free time slots\n   * @param {Date} start - Start of search period\n   * @param {Date} end - End of search period\n   * @param {number} duration - Required duration in minutes\n   * @param {Object} [options={}] - Options\n   * @returns {Array<{start: Date, end: Date}>} Free time slots\n   */\n  getFreePeriods(start, end, duration, options = {}) {\n    const opts = {\n      attendeeEmails: [],\n      businessHoursOnly: false,\n      businessHours: { start: '09:00', end: '17:00' },\n      excludeWeekends: false,\n      ...options\n    };\n\n    const freePeriods = [];\n\n    // Get busy periods\n    const busyPeriods = opts.attendeeEmails.length > 0\n      ? this.getBusyPeriods(opts.attendeeEmails, start, end)\n      : this._getAllBusyPeriods(start, end);\n\n    // Find gaps between busy periods\n    let currentTime = new Date(start);\n\n    for (const busy of busyPeriods) {\n      if (currentTime < busy.start) {\n        // Found a gap\n        const gapDuration = (busy.start - currentTime) / 60000; // minutes\n        if (gapDuration >= duration) {\n          // Check if within business hours if required\n          if (!opts.businessHoursOnly || this._isWithinBusinessHours(currentTime, busy.start, opts)) {\n            freePeriods.push({\n              start: new Date(currentTime),\n              end: new Date(busy.start)\n            });\n          }\n        }\n      }\n      currentTime = new Date(Math.max(currentTime.getTime(), busy.end.getTime()));\n    }\n\n    // Check final period\n    if (currentTime < end) {\n      const gapDuration = (end - currentTime) / 60000;\n      if (gapDuration >= duration) {\n        if (!opts.businessHoursOnly || this._isWithinBusinessHours(currentTime, end, opts)) {\n          freePeriods.push({\n            start: new Date(currentTime),\n            end: new Date(end)\n          });\n        }\n      }\n    }\n\n    return freePeriods;\n  }\n\n  /**\n   * Detect conflicts between two events\n   * @private\n   */\n  _detectEventConflicts(event1, event2, options) {\n    const conflicts = [];\n\n    // Check time overlap with buffer\n    const hasTimeOverlap = this._checkTimeOverlap(\n      event1,\n      event2,\n      options.bufferMinutes\n    );\n\n    if (hasTimeOverlap) {\n      // Time conflict\n      const timeConflict = this._createTimeConflict(event1, event2);\n      conflicts.push(timeConflict);\n\n      // Check attendee conflicts (only if time overlaps)\n      if (options.checkAttendees) {\n        const attendeeConflicts = this._checkAttendeeConflicts(event1, event2);\n        conflicts.push(...attendeeConflicts);\n      }\n\n      // Check resource conflicts (only if time overlaps)\n      if (options.checkResources) {\n        const resourceConflicts = this._checkResourceConflicts(event1, event2);\n        conflicts.push(...resourceConflicts);\n      }\n\n      // Check location conflicts (only if time overlaps)\n      if (options.checkLocation) {\n        const locationConflict = this._checkLocationConflict(event1, event2);\n        if (locationConflict) {\n          conflicts.push(locationConflict);\n        }\n      }\n    }\n\n    return conflicts;\n  }\n\n  /**\n   * Check for time overlap between events\n   * @private\n   */\n  _checkTimeOverlap(event1, event2, bufferMinutes = 0) {\n    const buffer = bufferMinutes * 60000; // Convert to milliseconds\n\n    const start1 = event1.start.getTime() - buffer;\n    const end1 = event1.end.getTime() + buffer;\n    const start2 = event2.start.getTime();\n    const end2 = event2.end.getTime();\n\n    return !(end1 <= start2 || end2 <= start1);\n  }\n\n  /**\n   * Create time conflict details\n   * @private\n   */\n  _createTimeConflict(event1, event2) {\n    const overlapStart = new Date(Math.max(event1.start.getTime(), event2.start.getTime()));\n    const overlapEnd = new Date(Math.min(event1.end.getTime(), event2.end.getTime()));\n    const overlapMinutes = (overlapEnd - overlapStart) / 60000;\n\n    // Determine severity based on overlap duration and event importance\n    let severity = 'low';\n    if (overlapMinutes >= 60) {\n      severity = 'high';\n    } else if (overlapMinutes >= 30) {\n      severity = 'medium';\n    }\n\n    // Increase severity for confirmed events\n    if (event1.status === 'confirmed' && event2.status === 'confirmed') {\n      severity = severity === 'low' ? 'medium' : severity === 'medium' ? 'high' : 'critical';\n    }\n\n    return {\n      id: `conflict_${++this.conflictIdCounter}`,\n      type: 'time',\n      severity,\n      eventId: event1.id,\n      conflictingEventId: event2.id,\n      description: `Time overlap: ${event1.title} conflicts with ${event2.title}`,\n      overlapStart,\n      overlapEnd,\n      overlapMinutes,\n      metadata: {\n        event1Title: event1.title,\n        event2Title: event2.title,\n        event1Status: event1.status,\n        event2Status: event2.status\n      }\n    };\n  }\n\n  /**\n   * Check for attendee conflicts\n   * @private\n   */\n  _checkAttendeeConflicts(event1, event2) {\n    const conflicts = [];\n\n    if (!event1.attendees || !event2.attendees) {\n      return conflicts;\n    }\n\n    const conflictingAttendees = [];\n\n    for (const attendee1 of event1.attendees) {\n      for (const attendee2 of event2.attendees) {\n        if (attendee1.email === attendee2.email) {\n          // Same attendee in both events\n          conflictingAttendees.push(attendee1.email);\n        }\n      }\n    }\n\n    if (conflictingAttendees.length > 0) {\n      // Determine severity based on attendee responses\n      let severity = 'medium';\n\n      // Check if any conflicting attendee has accepted both\n      const hasAcceptedBoth = conflictingAttendees.some(email => {\n        const a1 = event1.attendees.find(a => a.email === email);\n        const a2 = event2.attendees.find(a => a.email === email);\n        return a1?.responseStatus === 'accepted' && a2?.responseStatus === 'accepted';\n      });\n\n      if (hasAcceptedBoth) {\n        severity = 'critical';\n      }\n\n      conflicts.push({\n        id: `conflict_${++this.conflictIdCounter}`,\n        type: 'attendee',\n        severity,\n        eventId: event1.id,\n        conflictingEventId: event2.id,\n        description: `Attendee conflict: ${conflictingAttendees.length} attendee(s) double-booked`,\n        conflictingAttendees,\n        metadata: {\n          attendeeCount: conflictingAttendees.length,\n          attendeeEmails: conflictingAttendees\n        }\n      });\n    }\n\n    return conflicts;\n  }\n\n  /**\n   * Check for resource conflicts\n   * @private\n   */\n  _checkResourceConflicts(event1, event2) {\n    const conflicts = [];\n\n    // Check if events have resource attendees\n    const resources1 = event1.attendees?.filter(a => a.resource) || [];\n    const resources2 = event2.attendees?.filter(a => a.resource) || [];\n\n    for (const resource1 of resources1) {\n      for (const resource2 of resources2) {\n        if (resource1.email === resource2.email) {\n          conflicts.push({\n            id: `conflict_${++this.conflictIdCounter}`,\n            type: 'resource',\n            severity: 'critical', // Resource conflicts are always critical\n            eventId: event1.id,\n            conflictingEventId: event2.id,\n            description: `Resource conflict: ${resource1.name} is double-booked`,\n            conflictingResource: resource1.email,\n            metadata: {\n              resourceName: resource1.name,\n              resourceEmail: resource1.email\n            }\n          });\n        }\n      }\n    }\n\n    return conflicts;\n  }\n\n  /**\n   * Check for location conflicts\n   * @private\n   */\n  _checkLocationConflict(event1, event2) {\n    if (!event1.location || !event2.location) {\n      return null;\n    }\n\n    // Normalize locations for comparison\n    const loc1 = event1.location.trim().toLowerCase();\n    const loc2 = event2.location.trim().toLowerCase();\n\n    if (loc1 === loc2) {\n      return {\n        id: `conflict_${++this.conflictIdCounter}`,\n        type: 'location',\n        severity: 'high', // Location conflicts are typically high severity\n        eventId: event1.id,\n        conflictingEventId: event2.id,\n        description: `Location conflict: ${event1.location} is double-booked`,\n        metadata: {\n          location: event1.location\n        }\n      };\n    }\n\n    return null;\n  }\n\n  /**\n   * Build conflict summary\n   * @private\n   */\n  _buildConflictSummary(conflicts, affectedEventIds, affectedAttendees) {\n    const conflictsByType = {};\n    const conflictsBySeverity = {};\n\n    // Count by type and severity\n    for (const conflict of conflicts) {\n      conflictsByType[conflict.type] = (conflictsByType[conflict.type] || 0) + 1;\n      conflictsBySeverity[conflict.severity] = (conflictsBySeverity[conflict.severity] || 0) + 1;\n    }\n\n    return {\n      hasConflicts: conflicts.length > 0,\n      totalConflicts: conflicts.length,\n      conflicts,\n      conflictsByType,\n      conflictsBySeverity,\n      affectedEventIds: Array.from(affectedEventIds),\n      affectedAttendees: Array.from(affectedAttendees)\n    };\n  }\n\n  /**\n   * Merge overlapping busy periods\n   * @private\n   */\n  _mergeBusyPeriods(periods) {\n    if (periods.length <= 1) return periods;\n\n    // Sort by start time\n    periods.sort((a, b) => a.start - b.start);\n\n    const merged = [periods[0]];\n\n    for (let i = 1; i < periods.length; i++) {\n      const current = periods[i];\n      const last = merged[merged.length - 1];\n\n      if (current.start <= last.end) {\n        // Overlapping or adjacent, merge them\n        last.end = new Date(Math.max(last.end.getTime(), current.end.getTime()));\n        last.eventIds.push(...current.eventIds);\n      } else {\n        // No overlap, add as new period\n        merged.push(current);\n      }\n    }\n\n    return merged;\n  }\n\n  /**\n   * Get all busy periods\n   * @private\n   */\n  _getAllBusyPeriods(start, end) {\n    const events = this.eventStore.getEventsInRange(start, end, false)\n      .filter(e => e.status !== 'cancelled');\n\n    return events.map(event => ({\n      start: event.start,\n      end: event.end,\n      eventIds: [event.id]\n    })).sort((a, b) => a.start - b.start);\n  }\n\n  /**\n   * Check if time period is within business hours\n   * @private\n   */\n  _isWithinBusinessHours(start, end, options) {\n    // Simple implementation - can be enhanced\n    const startHour = start.getHours();\n    const endHour = end.getHours();\n\n    const businessStart = parseInt(options.businessHours.start.split(':')[0]);\n    const businessEnd = parseInt(options.businessHours.end.split(':')[0]);\n\n    return startHour >= businessStart && endHour <= businessEnd;\n  }\n}","import { Event } from './Event.js';\nimport { DateUtils } from '../calendar/DateUtils.js';\nimport { RecurrenceEngine } from './RecurrenceEngine.js';\nimport { PerformanceOptimizer } from '../performance/PerformanceOptimizer.js';\nimport { ConflictDetector } from '../conflicts/ConflictDetector.js';\nimport { TimezoneManager } from '../timezone/TimezoneManager.js';\n\n/**\n * EventStore - Manages calendar events with efficient querying\n * Uses Map for O(1) lookups and spatial indexing concepts for date queries\n * Now with performance optimizations for large datasets\n */\nexport class EventStore {\n  constructor(config = {}) {\n    // Primary storage - Map for O(1) ID lookups\n    /** @type {Map<string, Event>} */\n    this.events = new Map();\n\n    // Indices for efficient queries (using UTC for consistent indexing)\n    this.indices = {\n      /** @type {Map<string, Set<string>>} UTC Date string -> Set of event IDs */\n      byDate: new Map(),\n      /** @type {Map<string, Set<string>>} YYYY-MM (UTC) -> Set of event IDs */\n      byMonth: new Map(),\n      /** @type {Set<string>} Set of recurring event IDs */\n      recurring: new Set(),\n      /** @type {Map<string, Set<string>>} Category -> Set of event IDs */\n      byCategory: new Map(),\n      /** @type {Map<string, Set<string>>} Status -> Set of event IDs */\n      byStatus: new Map()\n    };\n\n    // Timezone manager for conversions\n    this.timezoneManager = new TimezoneManager();\n\n    // Default timezone for the store (can be overridden)\n    this.defaultTimezone = config.timezone || this.timezoneManager.getSystemTimezone();\n\n    // Performance optimizer\n    this.optimizer = new PerformanceOptimizer(config.performance);\n\n    // Conflict detector\n    this.conflictDetector = new ConflictDetector(this);\n\n    // Batch operation state\n    this.isBatchMode = false;\n    this.batchNotifications = [];\n    this.batchBackup = null; // For rollback support\n\n    // Change tracking\n    /** @type {number} */\n    this.version = 0;\n    /** @type {Set<import('../../types.js').EventListener>} */\n    this.listeners = new Set();\n  }\n\n  /**\n   * Add an event to the store\n   * @param {Event|import('../../types.js').EventData} event - The event to add\n   * @returns {Event} The added event\n   * @throws {Error} If event with same ID already exists\n   */\n  addEvent(event) {\n    return this.optimizer.measure('addEvent', () => {\n      if (!(event instanceof Event)) {\n        event = new Event(event);\n      }\n\n      if (this.events.has(event.id)) {\n        throw new Error(`Event with id ${event.id} already exists`);\n      }\n\n      // Store the event\n      this.events.set(event.id, event);\n\n      // Cache the event\n      this.optimizer.cache(event.id, event, 'event');\n\n      // Update indices\n      this._indexEvent(event);\n\n      // Notify listeners (batch if in batch mode)\n      if (this.isBatchMode) {\n        this.batchNotifications.push({\n          type: 'add',\n          event,\n          version: ++this.version\n        });\n      } else {\n        this._notifyChange({\n          type: 'add',\n          event,\n          version: ++this.version\n        });\n      }\n\n      return event;\n    });\n  }\n\n  /**\n   * Update an existing event\n   * @param {string} eventId - The event ID\n   * @param {Partial<import('../../types.js').EventData>} updates - Properties to update\n   * @returns {Event} The updated event\n   * @throws {Error} If event not found\n   */\n  updateEvent(eventId, updates) {\n    const existingEvent = this.events.get(eventId);\n    if (!existingEvent) {\n      throw new Error(`Event with id ${eventId} not found`);\n    }\n\n    // Remove old indices\n    this._unindexEvent(existingEvent);\n\n    // Create updated event\n    const updatedEvent = existingEvent.clone(updates);\n\n    // Store updated event\n    this.events.set(eventId, updatedEvent);\n\n    // Re-index\n    this._indexEvent(updatedEvent);\n\n    // Notify listeners\n    this._notifyChange({\n      type: 'update',\n      event: updatedEvent,\n      oldEvent: existingEvent,\n      version: ++this.version\n    });\n\n    return updatedEvent;\n  }\n\n  /**\n   * Remove an event from the store\n   * @param {string} eventId - The event ID to remove\n   * @returns {boolean} True if removed, false if not found\n   */\n  removeEvent(eventId) {\n    const event = this.events.get(eventId);\n    if (!event) {\n      return false;\n    }\n\n    // Remove from primary storage\n    this.events.delete(eventId);\n\n    // Remove from indices\n    this._unindexEvent(event);\n\n    // Notify listeners\n    this._notifyChange({\n      type: 'remove',\n      event,\n      version: ++this.version\n    });\n\n    return true;\n  }\n\n  /**\n   * Get an event by ID\n   * @param {string} eventId - The event ID\n   * @returns {Event|null} The event or null if not found\n   */\n  getEvent(eventId) {\n    // Check cache first\n    const cached = this.optimizer.getFromCache(eventId, 'event');\n    if (cached) {\n      return cached;\n    }\n\n    // Get from store\n    const event = this.events.get(eventId) || null;\n\n    // Cache if found\n    if (event) {\n      this.optimizer.cache(eventId, event, 'event');\n    }\n\n    return event;\n  }\n\n  /**\n   * Get all events\n   * @returns {Event[]} Array of all events\n   */\n  getAllEvents() {\n    return Array.from(this.events.values());\n  }\n\n  /**\n   * Query events with filters\n   * @param {import('../../types.js').QueryFilters} [filters={}] - Query filters\n   * @returns {Event[]} Filtered events\n   */\n  queryEvents(filters = {}) {\n    let results = Array.from(this.events.values());\n\n    // Filter by date range\n    if (filters.start || filters.end) {\n      const start = filters.start ? new Date(filters.start) : null;\n      const end = filters.end ? new Date(filters.end) : null;\n\n      results = results.filter(event => {\n        if (start && event.end < start) return false;\n        if (end && event.start > end) return false;\n        return true;\n      });\n    }\n\n    // Filter by specific date\n    if (filters.date) {\n      const date = new Date(filters.date);\n      results = results.filter(event => event.occursOn(date));\n    }\n\n    // Filter by month\n    if (filters.month && filters.year) {\n      const monthKey = `${filters.year}-${String(filters.month).padStart(2, '0')}`;\n      const eventIds = this.indices.byMonth.get(monthKey) || new Set();\n      results = results.filter(event => eventIds.has(event.id));\n    }\n\n    // Filter by all-day events\n    if (filters.hasOwnProperty('allDay')) {\n      results = results.filter(event => event.allDay === filters.allDay);\n    }\n\n    // Filter by recurring\n    if (filters.hasOwnProperty('recurring')) {\n      results = results.filter(event => event.recurring === filters.recurring);\n    }\n\n    // Filter by status\n    if (filters.status) {\n      results = results.filter(event => event.status === filters.status);\n    }\n\n    // Filter by categories\n    if (filters.categories && filters.categories.length > 0) {\n      results = results.filter(event =>\n        filters.matchAllCategories\n          ? event.hasAllCategories(filters.categories)\n          : event.hasAnyCategory(filters.categories)\n      );\n    }\n\n    // Filter by having attendees\n    if (filters.hasOwnProperty('hasAttendees')) {\n      results = results.filter(event => filters.hasAttendees ? event.hasAttendees : !event.hasAttendees);\n    }\n\n    // Filter by organizer email\n    if (filters.organizerEmail) {\n      results = results.filter(event =>\n        event.organizer && event.organizer.email === filters.organizerEmail\n      );\n    }\n\n    // Sort results\n    if (filters.sort) {\n      results.sort((a, b) => {\n        switch (filters.sort) {\n          case 'start':\n            return a.start - b.start;\n          case 'end':\n            return a.end - b.end;\n          case 'duration':\n            return a.duration - b.duration;\n          case 'title':\n            return a.title.localeCompare(b.title);\n          default:\n            return 0;\n        }\n      });\n    }\n\n    return results;\n  }\n\n  /**\n   * Get events for a specific date\n   * @param {Date} date - The date to query\n   * @param {string} [timezone] - Timezone for the query (defaults to store timezone)\n   * @returns {Event[]} Events occurring on the date, sorted by start time\n   */\n  getEventsForDate(date, timezone = null) {\n    timezone = timezone || this.defaultTimezone;\n\n    // Convert the date to UTC range for the timezone\n    const startOfDayLocal = new Date(date);\n    startOfDayLocal.setHours(0, 0, 0, 0);\n    const endOfDayLocal = new Date(date);\n    endOfDayLocal.setHours(23, 59, 59, 999);\n\n    // Convert to UTC for querying\n    const startUTC = this.timezoneManager.toUTC(startOfDayLocal, timezone);\n    const endUTC = this.timezoneManager.toUTC(endOfDayLocal, timezone);\n\n    // Use UTC date strings for index lookup\n    const dateStr = startUTC.toDateString();\n    const eventIds = this.indices.byDate.get(dateStr) || new Set();\n\n    return Array.from(eventIds)\n      .map(id => this.events.get(id))\n      .filter(event => {\n        if (!event) return false;\n        // Additional check to ensure event actually overlaps with the day in the given timezone\n        return event.startUTC <= endUTC && event.endUTC >= startUTC;\n      })\n      .sort((a, b) => {\n        // Sort by start time in the specified timezone\n        const aStart = a.getStartInTimezone(timezone);\n        const bStart = b.getStartInTimezone(timezone);\n        const timeCompare = aStart - bStart;\n        if (timeCompare !== 0) return timeCompare;\n        return b.duration - a.duration; // Longer events first\n      });\n  }\n\n  /**\n   * Get events that overlap with a given time range\n   * @param {Date} start - Start time\n   * @param {Date} end - End time\n   * @param {string} [excludeId=null] - Optional event ID to exclude (useful when checking for conflicts)\n   * @returns {Event[]} Array of overlapping events\n   */\n  getOverlappingEvents(start, end, excludeId = null) {\n    const overlapping = [];\n\n    // Get all events in the date range\n    const startDate = DateUtils.startOfDay(start);\n    const endDate = DateUtils.endOfDay(end);\n    const dates = DateUtils.getDateRange(startDate, endDate);\n\n    // Collect all events from those dates\n    const checkedIds = new Set();\n    dates.forEach(date => {\n      const dateStr = date.toDateString();\n      const eventIds = this.indices.byDate.get(dateStr) || new Set();\n\n      eventIds.forEach(id => {\n        if (!checkedIds.has(id) && id !== excludeId) {\n          checkedIds.add(id);\n          const event = this.events.get(id);\n\n          if (event && event.overlaps({ start, end })) {\n            overlapping.push(event);\n          }\n        }\n      });\n    });\n\n    return overlapping.sort((a, b) => a.start - b.start);\n  }\n\n  /**\n   * Check if an event would conflict with existing events\n   * @param {Date} start - Start time\n   * @param {Date} end - End time\n   * @param {string} excludeId - Optional event ID to exclude\n   * @returns {boolean} True if there are conflicts\n   */\n  hasConflicts(start, end, excludeId = null) {\n    return this.getOverlappingEvents(start, end, excludeId).length > 0;\n  }\n\n  /**\n   * Get events grouped by overlapping time slots\n   * Useful for calculating event positions in week/day views\n   * @param {Date} date - The date to analyze\n   * @param {boolean} timedOnly - Only include timed events (not all-day)\n   * @returns {Array<Event[]>} Array of event groups that overlap\n   */\n  getOverlapGroups(date, timedOnly = true) {\n    let events = this.getEventsForDate(date);\n\n    if (timedOnly) {\n      events = events.filter(e => !e.allDay);\n    }\n\n    const groups = [];\n    const processed = new Set();\n\n    events.forEach(event => {\n      if (processed.has(event.id)) return;\n\n      // Start a new group with this event\n      const group = [event];\n      processed.add(event.id);\n\n      // Find all events that overlap with any event in this group\n      let i = 0;\n      while (i < group.length) {\n        const currentEvent = group[i];\n\n        events.forEach(otherEvent => {\n          if (!processed.has(otherEvent.id) && currentEvent.overlaps(otherEvent)) {\n            group.push(otherEvent);\n            processed.add(otherEvent.id);\n          }\n        });\n\n        i++;\n      }\n\n      groups.push(group);\n    });\n\n    return groups;\n  }\n\n  /**\n   * Calculate positions for overlapping events (for rendering)\n   * @param {Event[]} events - Array of overlapping events\n   * @returns {Map<string, {column: number, totalColumns: number}>} Position data for each event\n   */\n  calculateEventPositions(events) {\n    const positions = new Map();\n\n    if (events.length === 0) return positions;\n\n    // Sort by start time, then by duration (longer events first)\n    events.sort((a, b) => {\n      const startDiff = a.start - b.start;\n      if (startDiff !== 0) return startDiff;\n      return (b.end - b.start) - (a.end - a.start);\n    });\n\n    // Track which columns are occupied at each time\n    const columns = [];\n\n    events.forEach(event => {\n      // Find the first available column\n      let column = 0;\n      while (column < columns.length) {\n        const columnEvents = columns[column];\n        const hasConflict = columnEvents.some(e => e.overlaps(event));\n\n        if (!hasConflict) {\n          break;\n        }\n        column++;\n      }\n\n      // Add event to the column\n      if (!columns[column]) {\n        columns[column] = [];\n      }\n      columns[column].push(event);\n\n      positions.set(event.id, {\n        column: column,\n        totalColumns: 0 // Will be updated after all events are placed\n      });\n    });\n\n    // Update total columns for all events\n    const totalColumns = columns.length;\n    positions.forEach(pos => {\n      pos.totalColumns = totalColumns;\n    });\n\n    return positions;\n  }\n\n  /**\n   * Get events for a date range\n   * @param {Date} start - Start date\n   * @param {Date} end - End date\n   * @param {boolean|string} expandRecurring - Whether to expand recurring events, or timezone string\n   * @param {string} [timezone] - Timezone for the query (if expandRecurring is boolean)\n   * @returns {Event[]}\n   */\n  getEventsInRange(start, end, expandRecurring = true, timezone = null) {\n    // Handle overloaded parameters\n    if (typeof expandRecurring === 'string') {\n      timezone = expandRecurring;\n      expandRecurring = true;\n    }\n\n    timezone = timezone || this.defaultTimezone;\n\n    // Convert range to UTC for querying\n    const startUTC = this.timezoneManager.toUTC(start, timezone);\n    const endUTC = this.timezoneManager.toUTC(end, timezone);\n\n    // Query using UTC times\n    const baseEvents = this.queryEvents({\n      start: startUTC,\n      end: endUTC,\n      sort: 'start'\n    });\n\n    if (!expandRecurring) {\n      return baseEvents;\n    }\n\n    // Expand recurring events\n    const expandedEvents = [];\n    baseEvents.forEach(event => {\n      if (event.recurring && event.recurrenceRule) {\n        const occurrences = this.expandRecurringEvent(event, start, end, timezone);\n        expandedEvents.push(...occurrences);\n      } else {\n        expandedEvents.push(event);\n      }\n    });\n\n    return expandedEvents.sort((a, b) => {\n      // Sort by start time in the specified timezone\n      const aStart = a.getStartInTimezone(timezone);\n      const bStart = b.getStartInTimezone(timezone);\n      return aStart - bStart;\n    });\n  }\n\n  /**\n   * Expand a recurring event into individual occurrences\n   * @param {Event} event - The recurring event\n   * @param {Date} rangeStart - Start of the expansion range\n   * @param {Date} rangeEnd - End of the expansion range\n   * @param {string} [timezone] - Timezone for the expansion\n   * @returns {Event[]} Array of event occurrences\n   */\n  expandRecurringEvent(event, rangeStart, rangeEnd, timezone = null) {\n    if (!event.recurring || !event.recurrenceRule) {\n      return [event];\n    }\n\n    timezone = timezone || this.defaultTimezone;\n\n    // Expand in the event's timezone for accurate recurrence calculation\n    const eventTimezone = event.timeZone || timezone;\n    const occurrences = RecurrenceEngine.expandEvent(event, rangeStart, rangeEnd);\n\n    return occurrences.map((occurrence, index) => {\n      // Create a new event instance for each occurrence\n      const occurrenceEvent = event.clone({\n        id: `${event.id}_occurrence_${index}`,\n        start: occurrence.start,\n        end: occurrence.end,\n        timeZone: eventTimezone,\n        metadata: {\n          ...event.metadata,\n          recurringEventId: event.id,\n          occurrenceIndex: index\n        }\n      });\n\n      return occurrenceEvent;\n    });\n  }\n\n  /**\n   * Clear all events\n   */\n  clear() {\n    const oldEvents = this.getAllEvents();\n\n    this.events.clear();\n    this.indices.byDate.clear();\n    this.indices.byMonth.clear();\n    this.indices.recurring.clear();\n\n    this._notifyChange({\n      type: 'clear',\n      oldEvents,\n      version: ++this.version\n    });\n  }\n\n  /**\n   * Bulk load events\n   * @param {Event[]} events - Array of events or event data\n   */\n  loadEvents(events) {\n    this.clear();\n\n    for (const eventData of events) {\n      this.addEvent(eventData);\n    }\n  }\n\n  /**\n   * Subscribe to store changes\n   * @param {Function} callback - Callback function\n   * @returns {Function} Unsubscribe function\n   */\n  subscribe(callback) {\n    this.listeners.add(callback);\n\n    return () => {\n      this.listeners.delete(callback);\n    };\n  }\n\n  /**\n   * Index an event for efficient queries\n   * @private\n   */\n  _indexEvent(event) {\n    // Check if should use lazy indexing for large date ranges\n    if (this.optimizer.shouldUseLazyIndexing(event)) {\n      this._indexEventLazy(event);\n      return;\n    }\n\n    // Use UTC times for consistent indexing across timezones\n    const startDate = DateUtils.startOfDay(new Date(event.startUTC || event.start));\n    const endDate = DateUtils.endOfDay(new Date(event.endUTC || event.end));\n\n    // For each day the event spans (in UTC), add to date index\n    const dates = DateUtils.getDateRange(startDate, endDate);\n\n    dates.forEach(date => {\n      const dateStr = date.toDateString();\n\n      if (!this.indices.byDate.has(dateStr)) {\n        this.indices.byDate.set(dateStr, new Set());\n      }\n      this.indices.byDate.get(dateStr).add(event.id);\n    });\n\n    // Index by month(s) using UTC\n    const startMonth = `${startDate.getFullYear()}-${String(startDate.getMonth() + 1).padStart(2, '0')}`;\n    const endMonth = `${endDate.getFullYear()}-${String(endDate.getMonth() + 1).padStart(2, '0')}`;\n\n    // Add to all months the event spans\n    const currentMonth = new Date(startDate.getFullYear(), startDate.getMonth(), 1);\n    while (currentMonth <= endDate) {\n      const monthKey = `${currentMonth.getFullYear()}-${String(currentMonth.getMonth() + 1).padStart(2, '0')}`;\n\n      if (!this.indices.byMonth.has(monthKey)) {\n        this.indices.byMonth.set(monthKey, new Set());\n      }\n      this.indices.byMonth.get(monthKey).add(event.id);\n\n      currentMonth.setMonth(currentMonth.getMonth() + 1);\n    }\n\n    // Index by categories\n    if (event.categories && event.categories.length > 0) {\n      event.categories.forEach(category => {\n        if (!this.indices.byCategory.has(category)) {\n          this.indices.byCategory.set(category, new Set());\n        }\n        this.indices.byCategory.get(category).add(event.id);\n      });\n    }\n\n    // Index by status\n    if (event.status) {\n      if (!this.indices.byStatus.has(event.status)) {\n        this.indices.byStatus.set(event.status, new Set());\n      }\n      this.indices.byStatus.get(event.status).add(event.id);\n    }\n\n    // Index recurring events\n    if (event.recurring) {\n      this.indices.recurring.add(event.id);\n    }\n  }\n\n  /**\n   * Lazy index for events with large date ranges\n   * @private\n   */\n  _indexEventLazy(event) {\n    // Create lazy index markers\n    const markers = this.optimizer.createLazyIndexMarkers(event);\n\n    // Index only the boundaries initially\n    const startDate = DateUtils.startOfDay(event.start);\n    const endDate = DateUtils.endOfDay(event.end);\n\n    // Index first week\n    const firstWeekEnd = new Date(startDate);\n    firstWeekEnd.setDate(firstWeekEnd.getDate() + 7);\n    const firstWeekDates = DateUtils.getDateRange(startDate,\n      firstWeekEnd < endDate ? firstWeekEnd : endDate);\n\n    firstWeekDates.forEach(date => {\n      const dateStr = date.toDateString();\n      if (!this.indices.byDate.has(dateStr)) {\n        this.indices.byDate.set(dateStr, new Set());\n      }\n      this.indices.byDate.get(dateStr).add(event.id);\n    });\n\n    // Index last week if different from first\n    if (endDate > firstWeekEnd) {\n      const lastWeekStart = new Date(endDate);\n      lastWeekStart.setDate(lastWeekStart.getDate() - 7);\n      const lastWeekDates = DateUtils.getDateRange(\n        lastWeekStart > startDate ? lastWeekStart : startDate,\n        endDate\n      );\n\n      lastWeekDates.forEach(date => {\n        const dateStr = date.toDateString();\n        if (!this.indices.byDate.has(dateStr)) {\n          this.indices.byDate.set(dateStr, new Set());\n        }\n        this.indices.byDate.get(dateStr).add(event.id);\n      });\n    }\n\n    // Index months as normal\n    const currentMonth = new Date(startDate.getFullYear(), startDate.getMonth(), 1);\n    while (currentMonth <= endDate) {\n      const monthKey = `${currentMonth.getFullYear()}-${String(currentMonth.getMonth() + 1).padStart(2, '0')}`;\n      if (!this.indices.byMonth.has(monthKey)) {\n        this.indices.byMonth.set(monthKey, new Set());\n      }\n      this.indices.byMonth.get(monthKey).add(event.id);\n      currentMonth.setMonth(currentMonth.getMonth() + 1);\n    }\n\n    // Index other properties normally\n    if (event.categories && event.categories.length > 0) {\n      event.categories.forEach(category => {\n        if (!this.indices.byCategory.has(category)) {\n          this.indices.byCategory.set(category, new Set());\n        }\n        this.indices.byCategory.get(category).add(event.id);\n      });\n    }\n\n    if (event.status) {\n      if (!this.indices.byStatus.has(event.status)) {\n        this.indices.byStatus.set(event.status, new Set());\n      }\n      this.indices.byStatus.get(event.status).add(event.id);\n    }\n\n    if (event.recurring) {\n      this.indices.recurring.add(event.id);\n    }\n  }\n\n  /**\n   * Remove event from indices\n   * @private\n   */\n  _unindexEvent(event) {\n    // Remove from date indices\n    for (const [dateStr, eventIds] of this.indices.byDate) {\n      eventIds.delete(event.id);\n      if (eventIds.size === 0) {\n        this.indices.byDate.delete(dateStr);\n      }\n    }\n\n    // Remove from month indices\n    for (const [monthKey, eventIds] of this.indices.byMonth) {\n      eventIds.delete(event.id);\n      if (eventIds.size === 0) {\n        this.indices.byMonth.delete(monthKey);\n      }\n    }\n\n    // Remove from recurring index\n    this.indices.recurring.delete(event.id);\n  }\n\n  /**\n   * Notify listeners of changes\n   * @private\n   */\n  _notifyChange(change) {\n    for (const listener of this.listeners) {\n      try {\n        listener(change);\n      } catch (error) {\n        console.error('Error in EventStore listener:', error);\n      }\n    }\n  }\n\n  /**\n   * Get store statistics\n   * @returns {Object}\n   */\n  getStats() {\n    return {\n      totalEvents: this.events.size,\n      recurringEvents: this.indices.recurring.size,\n      indexedDates: this.indices.byDate.size,\n      indexedMonths: this.indices.byMonth.size,\n      indexedCategories: this.indices.byCategory.size,\n      indexedStatuses: this.indices.byStatus.size,\n      version: this.version,\n      performanceMetrics: this.optimizer.getMetrics()\n    };\n  }\n\n  // ============ Batch Operations ============\n\n  /**\n   * Start batch mode for bulk operations\n   * Delays notifications until batch is committed\n   * @param {boolean} [enableRollback=false] - Enable rollback support (creates backup)\n   */\n  startBatch(enableRollback = false) {\n    this.isBatchMode = true;\n    this.batchNotifications = [];\n\n    // Create backup for rollback if requested\n    if (enableRollback) {\n      this.batchBackup = {\n        events: new Map(this.events),\n        indices: {\n          byDate: new Map(Array.from(this.indices.byDate.entries()).map(([k, v]) => [k, new Set(v)])),\n          byMonth: new Map(Array.from(this.indices.byMonth.entries()).map(([k, v]) => [k, new Set(v)])),\n          recurring: new Set(this.indices.recurring),\n          byCategory: new Map(Array.from(this.indices.byCategory.entries()).map(([k, v]) => [k, new Set(v)])),\n          byStatus: new Map(Array.from(this.indices.byStatus.entries()).map(([k, v]) => [k, new Set(v)]))\n        },\n        version: this.version\n      };\n    }\n  }\n\n  /**\n   * Commit batch operations\n   * Sends all notifications at once\n   */\n  commitBatch() {\n    if (!this.isBatchMode) return;\n\n    this.isBatchMode = false;\n\n    // Clear backup after successful commit\n    this.batchBackup = null;\n\n    // Send a single bulk notification\n    if (this.batchNotifications.length > 0) {\n      this._notifyChange({\n        type: 'batch',\n        changes: this.batchNotifications,\n        count: this.batchNotifications.length,\n        version: ++this.version\n      });\n    }\n\n    this.batchNotifications = [];\n  }\n\n  /**\n   * Rollback batch operations\n   * Restores state to before batch started\n   */\n  rollbackBatch() {\n    if (!this.isBatchMode) return;\n\n    this.isBatchMode = false;\n\n    // Restore backup if available\n    if (this.batchBackup) {\n      this.events = this.batchBackup.events;\n      this.indices = this.batchBackup.indices;\n      this.version = this.batchBackup.version;\n      this.batchBackup = null;\n\n      // Clear cache\n      this.optimizer.clearCache();\n    }\n\n    this.batchNotifications = [];\n  }\n\n  /**\n   * Execute batch operation with automatic rollback on error\n   * @param {Function} operation - Operation to execute\n   * @param {boolean} [enableRollback=true] - Enable automatic rollback on error\n   * @returns {*} Result of operation\n   * @throws {Error} If operation fails\n   */\n  async executeBatch(operation, enableRollback = true) {\n    this.startBatch(enableRollback);\n\n    try {\n      const result = await operation();\n      this.commitBatch();\n      return result;\n    } catch (error) {\n      if (enableRollback) {\n        this.rollbackBatch();\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Add multiple events in batch\n   * @param {Array<Event|import('../../types.js').EventData>} events - Events to add\n   * @returns {Event[]} Added events\n   */\n  addEvents(events) {\n    return this.optimizer.measure('addEvents', () => {\n      this.startBatch();\n      const results = [];\n      const errors = [];\n\n      for (const eventData of events) {\n        try {\n          results.push(this.addEvent(eventData));\n        } catch (error) {\n          errors.push({ event: eventData, error: error.message });\n        }\n      }\n\n      this.commitBatch();\n\n      if (errors.length > 0) {\n        console.warn(`Failed to add ${errors.length} events:`, errors);\n      }\n\n      return results;\n    });\n  }\n\n  /**\n   * Update multiple events in batch\n   * @param {Array<{id: string, updates: Object}>} updates - Update operations\n   * @returns {Event[]} Updated events\n   */\n  updateEvents(updates) {\n    return this.optimizer.measure('updateEvents', () => {\n      this.startBatch();\n      const results = [];\n      const errors = [];\n\n      for (const { id, updates: eventUpdates } of updates) {\n        try {\n          results.push(this.updateEvent(id, eventUpdates));\n        } catch (error) {\n          errors.push({ id, error: error.message });\n        }\n      }\n\n      this.commitBatch();\n\n      if (errors.length > 0) {\n        console.warn(`Failed to update ${errors.length} events:`, errors);\n      }\n\n      return results;\n    });\n  }\n\n  /**\n   * Remove multiple events in batch\n   * @param {string[]} eventIds - Event IDs to remove\n   * @returns {number} Number of events removed\n   */\n  removeEvents(eventIds) {\n    return this.optimizer.measure('removeEvents', () => {\n      this.startBatch();\n      let removed = 0;\n\n      for (const id of eventIds) {\n        if (this.removeEvent(id)) {\n          removed++;\n        }\n      }\n\n      this.commitBatch();\n      return removed;\n    });\n  }\n\n  // ============ Performance Methods ============\n\n  /**\n   * Get performance metrics\n   * @returns {Object} Performance metrics\n   */\n  getPerformanceMetrics() {\n    return this.optimizer.getMetrics();\n  }\n\n  /**\n   * Clear all caches\n   */\n  clearCaches() {\n    this.optimizer.eventCache.clear();\n    this.optimizer.queryCache.clear();\n    this.optimizer.dateRangeCache.clear();\n  }\n\n  /**\n   * Optimize indices by removing old or irrelevant entries\n   * @param {Date} [cutoffDate] - Remove indices older than this date\n   */\n  optimizeIndices(cutoffDate) {\n    if (!cutoffDate) {\n      cutoffDate = new Date();\n      cutoffDate.setMonth(cutoffDate.getMonth() - 6); // Default: 6 months ago\n    }\n\n    const cutoffStr = cutoffDate.toDateString();\n    let removed = 0;\n\n    // Clean up date indices\n    for (const [dateStr, eventIds] of this.indices.byDate) {\n      const date = new Date(dateStr);\n      if (date < cutoffDate) {\n        // Check if any events still need this index\n        let stillNeeded = false;\n        for (const eventId of eventIds) {\n          const event = this.events.get(eventId);\n          if (event && event.end >= cutoffDate) {\n            stillNeeded = true;\n            break;\n          }\n        }\n\n        if (!stillNeeded) {\n          this.indices.byDate.delete(dateStr);\n          removed++;\n        }\n      }\n    }\n\n    console.log(`Optimized indices: removed ${removed} old date entries`);\n    return removed;\n  }\n\n  /**\n   * Destroy the store and clean up resources\n   */\n  destroy() {\n    this.clear();\n    this.optimizer.destroy();\n    this.listeners.clear();\n  }\n\n  // ============ Conflict Detection Methods ============\n\n  /**\n   * Check for conflicts for an event\n   * @param {Event|import('../../types.js').EventData} event - Event to check\n   * @param {import('../../types.js').ConflictCheckOptions} [options={}] - Check options\n   * @returns {import('../../types.js').ConflictSummary} Conflict summary\n   */\n  checkConflicts(event, options = {}) {\n    return this.conflictDetector.checkConflicts(event, options);\n  }\n\n  /**\n   * Check conflicts between two events\n   * @param {string} eventId1 - First event ID\n   * @param {string} eventId2 - Second event ID\n   * @param {import('../../types.js').ConflictCheckOptions} [options={}] - Check options\n   * @returns {import('../../types.js').ConflictDetails[]} Conflicts between events\n   */\n  checkEventPairConflicts(eventId1, eventId2, options = {}) {\n    const event1 = this.getEvent(eventId1);\n    const event2 = this.getEvent(eventId2);\n\n    if (!event1 || !event2) {\n      throw new Error('One or both events not found');\n    }\n\n    return this.conflictDetector.checkEventPairConflicts(event1, event2, options);\n  }\n\n  /**\n   * Get all conflicts in a date range\n   * @param {Date} start - Start date\n   * @param {Date} end - End date\n   * @param {import('../../types.js').ConflictCheckOptions} [options={}] - Check options\n   * @returns {import('../../types.js').ConflictSummary} All conflicts in range\n   */\n  getAllConflicts(start, end, options = {}) {\n    const events = this.getEventsInRange(start, end, false);\n    const allConflicts = [];\n    const checkedPairs = new Set();\n\n    for (let i = 0; i < events.length; i++) {\n      for (let j = i + 1; j < events.length; j++) {\n        const pairKey = `${events[i].id}-${events[j].id}`;\n        if (!checkedPairs.has(pairKey)) {\n          checkedPairs.add(pairKey);\n          const conflicts = this.conflictDetector.checkEventPairConflicts(\n            events[i],\n            events[j],\n            options\n          );\n          allConflicts.push(...conflicts);\n        }\n      }\n    }\n\n    return this.conflictDetector._buildConflictSummary(\n      allConflicts,\n      new Set(events.map(e => e.id)),\n      new Set()\n    );\n  }\n\n  /**\n   * Get busy periods for attendees\n   * @param {string[]} attendeeEmails - Attendee emails\n   * @param {Date} start - Start date\n   * @param {Date} end - End date\n   * @param {Object} [options={}] - Options\n   * @returns {Array<{start: Date, end: Date, eventIds: string[]}>} Busy periods\n   */\n  getBusyPeriods(attendeeEmails, start, end, options = {}) {\n    return this.conflictDetector.getBusyPeriods(attendeeEmails, start, end, options);\n  }\n\n  /**\n   * Get free periods for scheduling\n   * @param {Date} start - Start date\n   * @param {Date} end - End date\n   * @param {number} durationMinutes - Required duration in minutes\n   * @param {Object} [options={}] - Options\n   * @returns {Array<{start: Date, end: Date}>} Free periods\n   */\n  getFreePeriods(start, end, durationMinutes, options = {}) {\n    return this.conflictDetector.getFreePeriods(start, end, durationMinutes, options);\n  }\n\n  /**\n   * Add event with conflict checking\n   * @param {Event|import('../../types.js').EventData} event - Event to add\n   * @param {boolean} [allowConflicts=true] - Whether to allow adding with conflicts\n   * @returns {{event: Event, conflicts: import('../../types.js').ConflictSummary}} Result\n   */\n  addEventWithConflictCheck(event, allowConflicts = true) {\n    // Check conflicts before adding\n    const conflicts = this.checkConflicts(event);\n\n    if (!allowConflicts && conflicts.hasConflicts) {\n      throw new Error(`Cannot add event: ${conflicts.totalConflicts} conflicts detected`);\n    }\n\n    // Add the event\n    const addedEvent = this.addEvent(event);\n\n    return {\n      event: addedEvent,\n      conflicts\n    };\n  }\n\n  /**\n   * Find events with conflicts\n   * @param {Object} [options={}] - Options\n   * @returns {Array<{event: Event, conflicts: import('../../types.js').ConflictDetails[]}>} Events with conflicts\n   */\n  findEventsWithConflicts(options = {}) {\n    const eventsWithConflicts = [];\n    const allEvents = this.getAllEvents();\n\n    for (const event of allEvents) {\n      const conflicts = this.checkConflicts(event, options);\n      if (conflicts.hasConflicts) {\n        eventsWithConflicts.push({\n          event,\n          conflicts: conflicts.conflicts\n        });\n      }\n    }\n\n    return eventsWithConflicts;\n  }\n}","/**\n * StateManager - Central state management for the calendar\n * Implements an immutable state pattern with change notifications\n */\nexport class StateManager {\n  /**\n   * Create a new StateManager instance\n   * @param {Partial<import('../../types.js').CalendarState>} [initialState={}] - Initial state values\n   */\n  constructor(initialState = {}) {\n    this.state = {\n      // Current view configuration\n      view: 'month', // 'month', 'week', 'day', 'list'\n      currentDate: new Date(),\n\n      // UI state\n      selectedEventId: null,\n      selectedDate: null,\n      hoveredEventId: null,\n      hoveredDate: null,\n\n      // Display options\n      weekStartsOn: 0, // 0 = Sunday, 1 = Monday, etc.\n      showWeekNumbers: false,\n      showWeekends: true,\n      fixedWeekCount: true, // Always show 6 weeks in month view\n\n      // Time configuration\n      timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n      locale: 'en-US',\n      hourFormat: '12h', // '12h' or '24h'\n\n      // Business hours (for week/day views)\n      businessHours: {\n        start: '09:00',\n        end: '17:00'\n      },\n\n      // Filters\n      filters: {\n        searchTerm: '',\n        categories: [],\n        showAllDay: true,\n        showTimed: true\n      },\n\n      // Interaction flags\n      isDragging: false,\n      isResizing: false,\n      isCreating: false,\n\n      // Loading states\n      isLoading: false,\n      loadingMessage: '',\n\n      // Error state\n      error: null,\n\n      // Custom metadata\n      metadata: {},\n\n      // Apply initial state overrides\n      ...initialState\n    };\n\n    // Observers for state changes\n    this.listeners = new Map();\n    this.globalListeners = new Set();\n\n    // History for undo/redo (optional)\n    this.history = [];\n    this.historyIndex = -1;\n    this.maxHistorySize = 50;\n  }\n\n  /**\n   * Get the current state\n   * @returns {import('../../types.js').CalendarState} Current state (frozen)\n   */\n  getState() {\n    return Object.freeze({ ...this.state });\n  }\n\n  /**\n   * Get a specific state value\n   * @param {keyof import('../../types.js').CalendarState} key - The state key\n   * @returns {any} The state value\n   */\n  get(key) {\n    return this.state[key];\n  }\n\n  /**\n   * Update state with partial updates\n   * @param {Object|Function} updates - Object with updates or updater function\n   */\n  setState(updates) {\n    const oldState = this.state;\n\n    // Support function updater pattern\n    if (typeof updates === 'function') {\n      updates = updates(oldState);\n    }\n\n    // Create new state with updates\n    const newState = {\n      ...oldState,\n      ...updates,\n      // Preserve nested objects\n      filters: updates.filters ? { ...oldState.filters, ...updates.filters } : oldState.filters,\n      businessHours: updates.businessHours ? { ...oldState.businessHours, ...updates.businessHours } : oldState.businessHours,\n      metadata: updates.metadata ? { ...oldState.metadata, ...updates.metadata } : oldState.metadata\n    };\n\n    // Check if state actually changed\n    if (this._hasChanged(oldState, newState)) {\n      this.state = newState;\n\n      // Add to history (store the new state)\n      this._addToHistory(newState);\n\n      // Notify listeners\n      this._notifyListeners(oldState, newState);\n    }\n  }\n\n  /**\n   * Set the current view\n   * @param {string} view - The view type\n   */\n  setView(view) {\n    const validViews = ['month', 'week', 'day', 'list'];\n    if (!validViews.includes(view)) {\n      throw new Error(`Invalid view: ${view}. Must be one of: ${validViews.join(', ')}`);\n    }\n    this.setState({ view });\n  }\n\n  /**\n   * Set the current date\n   * @param {Date} date - The date to set\n   */\n  setCurrentDate(date) {\n    if (!(date instanceof Date)) {\n      date = new Date(date);\n    }\n    if (isNaN(date.getTime())) {\n      throw new Error('Invalid date');\n    }\n    this.setState({ currentDate: date });\n  }\n\n  /**\n   * Navigate to the next period (month/week/day based on view)\n   */\n  navigateNext() {\n    const { view, currentDate } = this.state;\n    const newDate = new Date(currentDate);\n\n    switch (view) {\n      case 'month':\n        newDate.setMonth(newDate.getMonth() + 1);\n        break;\n      case 'week':\n        newDate.setDate(newDate.getDate() + 7);\n        break;\n      case 'day':\n        newDate.setDate(newDate.getDate() + 1);\n        break;\n    }\n\n    this.setCurrentDate(newDate);\n  }\n\n  /**\n   * Navigate to the previous period\n   */\n  navigatePrevious() {\n    const { view, currentDate } = this.state;\n    const newDate = new Date(currentDate);\n\n    switch (view) {\n      case 'month':\n        newDate.setMonth(newDate.getMonth() - 1);\n        break;\n      case 'week':\n        newDate.setDate(newDate.getDate() - 7);\n        break;\n      case 'day':\n        newDate.setDate(newDate.getDate() - 1);\n        break;\n    }\n\n    this.setCurrentDate(newDate);\n  }\n\n  /**\n   * Navigate to today\n   */\n  navigateToday() {\n    this.setCurrentDate(new Date());\n  }\n\n  /**\n   * Select an event\n   * @param {string} eventId - The event ID to select\n   */\n  selectEvent(eventId) {\n    this.setState({ selectedEventId: eventId });\n  }\n\n  /**\n   * Clear event selection\n   */\n  clearEventSelection() {\n    this.setState({ selectedEventId: null });\n  }\n\n  /**\n   * Select a date\n   * @param {Date} date - The date to select\n   */\n  selectDate(date) {\n    if (!(date instanceof Date)) {\n      date = new Date(date);\n    }\n    this.setState({ selectedDate: date });\n  }\n\n  /**\n   * Clear date selection\n   */\n  clearDateSelection() {\n    this.setState({ selectedDate: null });\n  }\n\n  /**\n   * Set loading state\n   * @param {boolean} isLoading - Loading state\n   * @param {string} message - Optional loading message\n   */\n  setLoading(isLoading, message = '') {\n    this.setState({\n      isLoading,\n      loadingMessage: message\n    });\n  }\n\n  /**\n   * Set error state\n   * @param {Error|string|null} error - The error\n   */\n  setError(error) {\n    this.setState({\n      error: error ? (error instanceof Error ? error.message : error) : null\n    });\n  }\n\n  /**\n   * Update filters\n   * @param {Object} filters - Filter updates\n   */\n  updateFilters(filters) {\n    this.setState({\n      filters: {\n        ...this.state.filters,\n        ...filters\n      }\n    });\n  }\n\n  /**\n   * Subscribe to all state changes\n   * @param {Function} callback - Callback function\n   * @returns {Function} Unsubscribe function\n   */\n  subscribe(callback) {\n    this.globalListeners.add(callback);\n\n    return () => {\n      this.globalListeners.delete(callback);\n    };\n  }\n\n  /**\n   * Subscribe to specific state key changes\n   * @param {string|string[]} keys - State key(s) to watch\n   * @param {Function} callback - Callback function\n   * @returns {Function} Unsubscribe function\n   */\n  watch(keys, callback) {\n    const keyArray = Array.isArray(keys) ? keys : [keys];\n\n    keyArray.forEach(key => {\n      if (!this.listeners.has(key)) {\n        this.listeners.set(key, new Set());\n      }\n      this.listeners.get(key).add(callback);\n    });\n\n    return () => {\n      keyArray.forEach(key => {\n        const callbacks = this.listeners.get(key);\n        if (callbacks) {\n          callbacks.delete(callback);\n          if (callbacks.size === 0) {\n            this.listeners.delete(key);\n          }\n        }\n      });\n    };\n  }\n\n  /**\n   * Check if undo is available\n   * @returns {boolean} True if undo is available\n   */\n  canUndo() {\n    return this.historyIndex > 0;\n  }\n\n  /**\n   * Check if redo is available\n   * @returns {boolean} True if redo is available\n   */\n  canRedo() {\n    return this.historyIndex < this.history.length - 1;\n  }\n\n  /**\n   * Get the number of undo operations available\n   * @returns {number} Number of undo operations\n   */\n  getUndoCount() {\n    return this.historyIndex;\n  }\n\n  /**\n   * Get the number of redo operations available\n   * @returns {number} Number of redo operations\n   */\n  getRedoCount() {\n    return this.history.length - 1 - this.historyIndex;\n  }\n\n  /**\n   * Undo the last state change\n   * @returns {boolean} True if undo was performed\n   */\n  undo() {\n    if (!this.canUndo()) {\n      return false;\n    }\n\n    this.historyIndex--;\n    const previousState = this.history[this.historyIndex];\n    const currentState = this.state;\n\n    // Update state without adding to history\n    this.state = { ...previousState };\n\n    // Notify listeners\n    this._notifyListeners(currentState, this.state);\n\n    return true;\n  }\n\n  /**\n   * Redo the next state change\n   * @returns {boolean} True if redo was performed\n   */\n  redo() {\n    if (!this.canRedo()) {\n      return false;\n    }\n\n    this.historyIndex++;\n    const nextState = this.history[this.historyIndex];\n    const currentState = this.state;\n\n    // Update state without adding to history\n    this.state = { ...nextState };\n\n    // Notify listeners\n    this._notifyListeners(currentState, this.state);\n\n    return true;\n  }\n\n  /**\n   * Reset state to initial values\n   */\n  reset() {\n    const initialState = this.history[0] || {};\n    this.setState(initialState);\n    this.history = [initialState];\n    this.historyIndex = 0;\n  }\n\n  /**\n   * Check if state has changed\n   * @private\n   */\n  _hasChanged(oldState, newState) {\n    return !this._deepEqual(oldState, newState);\n  }\n\n  /**\n   * Deep equality check optimized for state comparison\n   * @private\n   * @param {*} a - First value\n   * @param {*} b - Second value\n   * @param {Set} seen - Track circular references\n   * @returns {boolean} True if values are deeply equal\n   */\n  _deepEqual(a, b, seen = new Set()) {\n    // Same reference\n    if (a === b) return true;\n\n    // Different types or null/undefined\n    if (a == null || b == null) return a === b;\n    if (typeof a !== typeof b) return false;\n\n    // Primitives\n    if (typeof a !== 'object') return a === b;\n\n    // Check for circular references\n    if (seen.has(a) || seen.has(b)) return false;\n    seen.add(a);\n    seen.add(b);\n\n    // Arrays\n    if (Array.isArray(a)) {\n      if (!Array.isArray(b) || a.length !== b.length) {\n        seen.delete(a);\n        seen.delete(b);\n        return false;\n      }\n\n      for (let i = 0; i < a.length; i++) {\n        if (!this._deepEqual(a[i], b[i], seen)) {\n          seen.delete(a);\n          seen.delete(b);\n          return false;\n        }\n      }\n\n      seen.delete(a);\n      seen.delete(b);\n      return true;\n    }\n\n    // Dates\n    if (a instanceof Date && b instanceof Date) {\n      const result = a.getTime() === b.getTime();\n      seen.delete(a);\n      seen.delete(b);\n      return result;\n    }\n\n    // Objects\n    const aKeys = Object.keys(a);\n    const bKeys = Object.keys(b);\n\n    if (aKeys.length !== bKeys.length) {\n      seen.delete(a);\n      seen.delete(b);\n      return false;\n    }\n\n    // Sort keys for consistent comparison\n    aKeys.sort();\n    bKeys.sort();\n\n    // Compare keys\n    for (let i = 0; i < aKeys.length; i++) {\n      if (aKeys[i] !== bKeys[i]) {\n        seen.delete(a);\n        seen.delete(b);\n        return false;\n      }\n    }\n\n    // Compare values\n    for (const key of aKeys) {\n      if (!this._deepEqual(a[key], b[key], seen)) {\n        seen.delete(a);\n        seen.delete(b);\n        return false;\n      }\n    }\n\n    seen.delete(a);\n    seen.delete(b);\n    return true;\n  }\n\n  /**\n   * Add state to history\n   * @private\n   */\n  _addToHistory(state) {\n    // Remove any future history if we're not at the end\n    if (this.historyIndex < this.history.length - 1) {\n      this.history = this.history.slice(0, this.historyIndex + 1);\n    }\n\n    // Add new state\n    this.history.push({ ...state });\n    this.historyIndex++;\n\n    // Limit history size\n    if (this.history.length > this.maxHistorySize) {\n      this.history.shift();\n      this.historyIndex--;\n    }\n  }\n\n  /**\n   * Notify listeners of state changes\n   * @private\n   */\n  _notifyListeners(oldState, newState) {\n    // Notify global listeners\n    for (const callback of this.globalListeners) {\n      try {\n        callback(newState, oldState);\n      } catch (error) {\n        console.error('Error in state listener:', error);\n      }\n    }\n\n    // Notify specific key listeners\n    for (const [key, callbacks] of this.listeners) {\n      if (oldState[key] !== newState[key]) {\n        for (const callback of callbacks) {\n          try {\n            callback(newState[key], oldState[key], newState, oldState);\n          } catch (error) {\n            console.error(`Error in state listener for key \"${key}\":`, error);\n          }\n        }\n      }\n    }\n  }\n}","import { EventStore } from '../events/EventStore.js';\nimport { StateManager } from '../state/StateManager.js';\nimport { DateUtils } from './DateUtils.js';\nimport { TimezoneManager } from '../timezone/TimezoneManager.js';\n\n/**\n * Calendar - Main calendar class with full timezone support\n * Pure JavaScript, no DOM dependencies\n * Framework agnostic, Locker Service compatible\n */\nexport class Calendar {\n  /**\n   * Create a new Calendar instance\n   * @param {import('../../types.js').CalendarConfig} [config={}] - Configuration options\n   */\n  constructor(config = {}) {\n    // Initialize timezone manager first\n    this.timezoneManager = new TimezoneManager();\n\n    // Initialize configuration\n    this.config = {\n      view: 'month',\n      date: new Date(),\n      weekStartsOn: 0, // 0 = Sunday\n      locale: 'en-US',\n      timeZone: config.timeZone || this.timezoneManager.getSystemTimezone(),\n      showWeekNumbers: false,\n      showWeekends: true,\n      fixedWeekCount: true,\n      businessHours: {\n        start: '09:00',\n        end: '17:00'\n      },\n      ...config\n    };\n\n    // Initialize core components with timezone support\n    this.eventStore = new EventStore({ timezone: this.config.timeZone });\n    this.state = new StateManager({\n      view: this.config.view,\n      currentDate: this.config.date,\n      weekStartsOn: this.config.weekStartsOn,\n      locale: this.config.locale,\n      timeZone: this.config.timeZone,\n      showWeekNumbers: this.config.showWeekNumbers,\n      showWeekends: this.config.showWeekends,\n      fixedWeekCount: this.config.fixedWeekCount,\n      businessHours: this.config.businessHours\n    });\n\n    // Event emitter for calendar events\n    this.listeners = new Map();\n\n    // Plugins\n    this.plugins = new Set();\n\n    // View instances (lazy loaded)\n    this.views = new Map();\n\n    // Set up internal listeners\n    this._setupInternalListeners();\n\n    // Load initial events if provided\n    if (config.events) {\n      this.setEvents(config.events);\n    }\n  }\n\n  /**\n   * Set the calendar view\n   * @param {import('../../types.js').ViewType} viewType - The view type ('month', 'week', 'day', 'list')\n   * @param {Date} [date=null] - Optional date to navigate to\n   */\n  setView(viewType, date = null) {\n    this.state.setView(viewType);\n\n    if (date) {\n      this.state.setCurrentDate(date);\n    }\n\n    this._emit('viewChange', {\n      view: viewType,\n      date: date || this.state.get('currentDate')\n    });\n  }\n\n  /**\n   * Get the current view type\n   * @returns {import('../../types.js').ViewType} The current view type\n   */\n  getView() {\n    return this.state.get('view');\n  }\n\n  /**\n   * Navigate to the next period\n   */\n  next() {\n    this.state.navigateNext();\n    this._emit('navigate', {\n      direction: 'next',\n      date: this.state.get('currentDate'),\n      view: this.state.get('view')\n    });\n  }\n\n  /**\n   * Navigate to the previous period\n   */\n  previous() {\n    this.state.navigatePrevious();\n    this._emit('navigate', {\n      direction: 'previous',\n      date: this.state.get('currentDate'),\n      view: this.state.get('view')\n    });\n  }\n\n  /**\n   * Navigate to today\n   */\n  today() {\n    this.state.navigateToday();\n    this._emit('navigate', {\n      direction: 'today',\n      date: this.state.get('currentDate'),\n      view: this.state.get('view')\n    });\n  }\n\n  /**\n   * Navigate to a specific date\n   * @param {Date} date - The date to navigate to\n   */\n  goToDate(date) {\n    this.state.setCurrentDate(date);\n    this._emit('navigate', {\n      direction: 'goto',\n      date: date,\n      view: this.state.get('view')\n    });\n  }\n\n  /**\n   * Get the current date\n   * @returns {Date}\n   */\n  getCurrentDate() {\n    return new Date(this.state.get('currentDate'));\n  }\n\n  /**\n   * Add an event\n   * @param {import('../events/Event.js').Event|import('../../types.js').EventData} eventData - Event data or Event instance\n   * @returns {import('../events/Event.js').Event} The added event\n   */\n  addEvent(eventData) {\n    const event = this.eventStore.addEvent(eventData);\n\n    this._emit('eventAdd', { event });\n\n    return event;\n  }\n\n  /**\n   * Update an event\n   * @param {string} eventId - The event ID\n   * @param {Object} updates - Properties to update\n   * @returns {Event} The updated event\n   */\n  updateEvent(eventId, updates) {\n    const oldEvent = this.eventStore.getEvent(eventId);\n    const event = this.eventStore.updateEvent(eventId, updates);\n\n    this._emit('eventUpdate', { event, oldEvent });\n\n    return event;\n  }\n\n  /**\n   * Remove an event\n   * @param {string} eventId - The event ID\n   * @returns {boolean} True if removed\n   */\n  removeEvent(eventId) {\n    const event = this.eventStore.getEvent(eventId);\n    const removed = this.eventStore.removeEvent(eventId);\n\n    if (removed) {\n      this._emit('eventRemove', { event });\n    }\n\n    return removed;\n  }\n\n  /**\n   * Get an event by ID\n   * @param {string} eventId - The event ID\n   * @returns {Event|null}\n   */\n  getEvent(eventId) {\n    return this.eventStore.getEvent(eventId);\n  }\n\n  /**\n   * Get all events\n   * @returns {Event[]}\n   */\n  getEvents() {\n    return this.eventStore.getAllEvents();\n  }\n\n  /**\n   * Set all events (replaces existing)\n   * @param {Event[]} events - Array of events\n   */\n  setEvents(events) {\n    this.eventStore.loadEvents(events);\n    this._emit('eventsSet', { events: this.getEvents() });\n  }\n\n  /**\n   * Query events with filters\n   * @param {Object} filters - Query filters\n   * @returns {Event[]}\n   */\n  queryEvents(filters) {\n    return this.eventStore.queryEvents(filters);\n  }\n\n  /**\n   * Get events for a specific date\n   * @param {Date} date - The date\n   * @param {string} [timezone] - Timezone for the query (defaults to calendar timezone)\n   * @returns {Event[]}\n   */\n  getEventsForDate(date, timezone = null) {\n    return this.eventStore.getEventsForDate(date, timezone || this.config.timeZone);\n  }\n\n  /**\n   * Get events in a date range\n   * @param {Date} start - Start date\n   * @param {Date} end - End date\n   * @param {string} [timezone] - Timezone for the query (defaults to calendar timezone)\n   * @returns {Event[]}\n   */\n  getEventsInRange(start, end, timezone = null) {\n    return this.eventStore.getEventsInRange(start, end, true, timezone || this.config.timeZone);\n  }\n\n  /**\n   * Set the calendar's timezone\n   * @param {string} timezone - IANA timezone identifier\n   */\n  setTimezone(timezone) {\n    const parsedTimezone = this.timezoneManager.parseTimezone(timezone);\n    const previousTimezone = this.config.timeZone;\n\n    this.config.timeZone = parsedTimezone;\n    this.eventStore.defaultTimezone = parsedTimezone;\n    this.state.setState({ timeZone: parsedTimezone });\n\n    this._emit('timezoneChange', {\n      timezone: parsedTimezone,\n      previousTimezone: previousTimezone\n    });\n  }\n\n  /**\n   * Get the current timezone\n   * @returns {string} Current timezone\n   */\n  getTimezone() {\n    return this.config.timeZone;\n  }\n\n  /**\n   * Convert a date from one timezone to another\n   * @param {Date} date - Date to convert\n   * @param {string} fromTimezone - Source timezone\n   * @param {string} toTimezone - Target timezone\n   * @returns {Date} Converted date\n   */\n  convertTimezone(date, fromTimezone, toTimezone) {\n    return this.timezoneManager.convertTimezone(date, fromTimezone, toTimezone);\n  }\n\n  /**\n   * Convert a date to the calendar's timezone\n   * @param {Date} date - Date to convert\n   * @param {string} fromTimezone - Source timezone\n   * @returns {Date} Date in calendar timezone\n   */\n  toCalendarTimezone(date, fromTimezone) {\n    return this.timezoneManager.convertTimezone(date, fromTimezone, this.config.timeZone);\n  }\n\n  /**\n   * Convert a date from the calendar's timezone\n   * @param {Date} date - Date in calendar timezone\n   * @param {string} toTimezone - Target timezone\n   * @returns {Date} Converted date\n   */\n  fromCalendarTimezone(date, toTimezone) {\n    return this.timezoneManager.convertTimezone(date, this.config.timeZone, toTimezone);\n  }\n\n  /**\n   * Format a date in a specific timezone\n   * @param {Date} date - Date to format\n   * @param {string} [timezone] - Timezone for formatting (defaults to calendar timezone)\n   * @param {Object} [options] - Formatting options\n   * @returns {string} Formatted date string\n   */\n  formatInTimezone(date, timezone = null, options = {}) {\n    return this.timezoneManager.formatInTimezone(\n      date,\n      timezone || this.config.timeZone,\n      options\n    );\n  }\n\n  /**\n   * Get list of common timezones with offsets\n   * @returns {Array<{value: string, label: string, offset: string}>} Timezone list\n   */\n  getTimezones() {\n    return this.timezoneManager.getCommonTimezones();\n  }\n\n  /**\n   * Get overlapping event groups for a date\n   * @param {Date} date - The date to check\n   * @param {boolean} timedOnly - Only include timed events\n   * @returns {Array<Event[]>} Array of event groups that overlap\n   */\n  getOverlapGroups(date, timedOnly = true) {\n    return this.eventStore.getOverlapGroups(date, timedOnly);\n  }\n\n  /**\n   * Calculate event positions for rendering\n   * @param {Event[]} events - Array of overlapping events\n   * @returns {Map<string, {column: number, totalColumns: number}>} Position data\n   */\n  calculateEventPositions(events) {\n    return this.eventStore.calculateEventPositions(events);\n  }\n\n  /**\n   * Get the current view's data\n   * @returns {import('../../types.js').MonthViewData|import('../../types.js').WeekViewData|import('../../types.js').DayViewData|import('../../types.js').ListViewData|null} View-specific data\n   */\n  getViewData() {\n    const view = this.state.get('view');\n    const currentDate = this.state.get('currentDate');\n\n    switch (view) {\n      case 'month':\n        return this._getMonthViewData(currentDate);\n      case 'week':\n        return this._getWeekViewData(currentDate);\n      case 'day':\n        return this._getDayViewData(currentDate);\n      case 'list':\n        return this._getListViewData(currentDate);\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * Get month view data\n   * @private\n   */\n  _getMonthViewData(date) {\n    const year = date.getFullYear();\n    const month = date.getMonth();\n    const weekStartsOn = this.state.get('weekStartsOn');\n    const fixedWeekCount = this.state.get('fixedWeekCount');\n\n    // Get the first day of the month\n    const firstDay = new Date(year, month, 1);\n\n    // Get the last day of the month\n    const lastDay = new Date(year, month + 1, 0);\n\n    // Calculate the start date (beginning of the week containing the first day)\n    const startDate = DateUtils.startOfWeek(firstDay, weekStartsOn);\n\n    // Calculate weeks\n    const weeks = [];\n    let currentDate = new Date(startDate);\n\n    // Generate weeks\n    const maxWeeks = fixedWeekCount ? 6 : Math.ceil((lastDay.getDate() + DateUtils.getDayOfWeek(firstDay, weekStartsOn)) / 7);\n\n    for (let weekIndex = 0; weekIndex < maxWeeks; weekIndex++) {\n      const week = {\n        weekNumber: DateUtils.getWeekNumber(currentDate),\n        days: []\n      };\n\n      for (let dayIndex = 0; dayIndex < 7; dayIndex++) {\n        const dayDate = new Date(currentDate);\n        const isCurrentMonth = dayDate.getMonth() === month;\n        const isToday = DateUtils.isToday(dayDate);\n        const isWeekend = dayDate.getDay() === 0 || dayDate.getDay() === 6;\n\n        week.days.push({\n          date: dayDate,\n          dayOfMonth: dayDate.getDate(),\n          isCurrentMonth,\n          isToday,\n          isWeekend,\n          events: this.getEventsForDate(dayDate)\n        });\n\n        // Use DateUtils.addDays to handle month boundaries correctly\n        currentDate = DateUtils.addDays(currentDate, 1);\n      }\n\n      weeks.push(week);\n    }\n\n    return {\n      type: 'month',\n      year,\n      month,\n      monthName: DateUtils.getMonthName(date, this.state.get('locale')),\n      weeks,\n      startDate,\n      endDate: new Date(currentDate.getTime() - 1) // Last moment of the view\n    };\n  }\n\n  /**\n   * Get week view data\n   * @private\n   */\n  _getWeekViewData(date) {\n    const weekStartsOn = this.state.get('weekStartsOn');\n    const startDate = DateUtils.startOfWeek(date, weekStartsOn);\n    const endDate = DateUtils.endOfWeek(date, weekStartsOn);\n\n    const days = [];\n    const currentDate = new Date(startDate);\n\n    for (let i = 0; i < 7; i++) {\n      const dayDate = new Date(currentDate);\n      days.push({\n        date: dayDate,\n        dayOfWeek: dayDate.getDay(),\n        dayName: DateUtils.getDayName(dayDate, this.state.get('locale')),\n        isToday: DateUtils.isToday(dayDate),\n        isWeekend: dayDate.getDay() === 0 || dayDate.getDay() === 6,\n        events: this.getEventsForDate(dayDate),\n        // Add overlap groups for positioning overlapping events\n        overlapGroups: this.eventStore.getOverlapGroups(dayDate, true),\n        getEventPositions: (events) => this.eventStore.calculateEventPositions(events)\n      });\n      // Use DateUtils.addDays to handle month boundaries correctly\n      currentDate = DateUtils.addDays(currentDate, 1);\n    }\n\n    return {\n      type: 'week',\n      weekNumber: DateUtils.getWeekNumber(startDate),\n      startDate,\n      endDate,\n      days\n    };\n  }\n\n  /**\n   * Get day view data\n   * @private\n   */\n  _getDayViewData(date) {\n    const events = this.getEventsForDate(date);\n\n    // Separate all-day and timed events\n    const allDayEvents = events.filter(e => e.allDay);\n    const timedEvents = events.filter(e => !e.allDay);\n\n    // Create hourly slots for timed events\n    const hours = [];\n    for (let hour = 0; hour < 24; hour++) {\n      const hourDate = new Date(date);\n      hourDate.setHours(hour, 0, 0, 0);\n      const hourEnd = new Date(date);\n      hourEnd.setHours(hour + 1, 0, 0, 0);\n\n      hours.push({\n        hour,\n        time: DateUtils.formatTime(hourDate, this.state.get('locale')),\n        events: timedEvents.filter(event => {\n          // Check if event occurs during this hour (not just starts)\n          // Event occurs in this hour if it overlaps with the hour slot\n          return event.start < hourEnd && event.end > hourDate;\n        })\n      });\n    }\n\n    return {\n      type: 'day',\n      date,\n      dayName: DateUtils.getDayName(date, this.state.get('locale')),\n      isToday: DateUtils.isToday(date),\n      allDayEvents,\n      hours\n    };\n  }\n\n  /**\n   * Get list view data\n   * @private\n   */\n  _getListViewData(date) {\n    // Get events for the next 30 days\n    const startDate = new Date(date);\n    startDate.setHours(0, 0, 0, 0);\n\n    const endDate = new Date(startDate);\n    endDate.setDate(endDate.getDate() + 30);\n\n    const events = this.getEventsInRange(startDate, endDate);\n\n    // Group events by day\n    const groupedEvents = new Map();\n\n    events.forEach(event => {\n      const dateKey = event.start.toDateString();\n      if (!groupedEvents.has(dateKey)) {\n        groupedEvents.set(dateKey, {\n          date: new Date(event.start),\n          events: []\n        });\n      }\n      groupedEvents.get(dateKey).events.push(event);\n    });\n\n    // Convert to sorted array\n    const days = Array.from(groupedEvents.values())\n      .sort((a, b) => a.date - b.date)\n      .map(day => ({\n        ...day,\n        dayName: DateUtils.getDayName(day.date, this.state.get('locale')),\n        isToday: DateUtils.isToday(day.date)\n      }));\n\n    return {\n      type: 'list',\n      startDate,\n      endDate,\n      days,\n      totalEvents: events.length\n    };\n  }\n\n  /**\n   * Select an event\n   * @param {string} eventId - Event ID to select\n   */\n  selectEvent(eventId) {\n    const event = this.getEvent(eventId);\n    if (event) {\n      this.state.selectEvent(eventId);\n      this._emit('eventSelect', { event });\n    }\n  }\n\n  /**\n   * Clear event selection\n   */\n  clearEventSelection() {\n    const eventId = this.state.get('selectedEventId');\n    this.state.clearEventSelection();\n\n    if (eventId) {\n      this._emit('eventDeselect', { eventId });\n    }\n  }\n\n  /**\n   * Select a date\n   * @param {Date} date - Date to select\n   */\n  selectDate(date) {\n    this.state.selectDate(date);\n    this._emit('dateSelect', { date });\n  }\n\n  /**\n   * Clear date selection\n   */\n  clearDateSelection() {\n    const date = this.state.get('selectedDate');\n    this.state.clearDateSelection();\n\n    if (date) {\n      this._emit('dateDeselect', { date });\n    }\n  }\n\n  /**\n   * Subscribe to calendar events\n   * @param {string} eventName - Event name\n   * @param {Function} callback - Callback function\n   * @returns {Function} Unsubscribe function\n   */\n  on(eventName, callback) {\n    if (!this.listeners.has(eventName)) {\n      this.listeners.set(eventName, new Set());\n    }\n    this.listeners.get(eventName).add(callback);\n\n    return () => this.off(eventName, callback);\n  }\n\n  /**\n   * Unsubscribe from calendar events\n   * @param {string} eventName - Event name\n   * @param {Function} callback - Callback function\n   */\n  off(eventName, callback) {\n    const callbacks = this.listeners.get(eventName);\n    if (callbacks) {\n      callbacks.delete(callback);\n      if (callbacks.size === 0) {\n        this.listeners.delete(eventName);\n      }\n    }\n  }\n\n  /**\n   * Emit an event\n   * @private\n   */\n  _emit(eventName, data) {\n    const callbacks = this.listeners.get(eventName);\n    if (callbacks) {\n      callbacks.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error(`Error in event listener for \"${eventName}\":`, error);\n        }\n      });\n    }\n  }\n\n  /**\n   * Set up internal listeners\n   * @private\n   */\n  _setupInternalListeners() {\n    // Listen to state changes\n    this.state.subscribe((newState, oldState) => {\n      this._emit('stateChange', { newState, oldState });\n    });\n\n    // Listen to event store changes\n    this.eventStore.subscribe((change) => {\n      this._emit('eventStoreChange', change);\n    });\n  }\n\n  /**\n   * Install a plugin\n   * @param {Object} plugin - Plugin object with install method\n   */\n  use(plugin) {\n    if (this.plugins.has(plugin)) {\n      console.warn('Plugin already installed');\n      return;\n    }\n\n    if (typeof plugin.install === 'function') {\n      plugin.install(this);\n      this.plugins.add(plugin);\n    } else {\n      throw new Error('Plugin must have an install method');\n    }\n  }\n\n  /**\n   * Destroy the calendar and clean up\n   */\n  destroy() {\n    // Clear all listeners\n    this.listeners.clear();\n\n    // Clear stores\n    this.eventStore.clear();\n\n    // Clear plugins\n    this.plugins.forEach(plugin => {\n      if (typeof plugin.uninstall === 'function') {\n        plugin.uninstall(this);\n      }\n    });\n    this.plugins.clear();\n\n    this._emit('destroy');\n  }\n}// Test workflow\n","/**\n * Lightning Calendar Core - Main entry point\n * A modern, lightweight, framework-agnostic calendar library\n * Optimized for Salesforce Lightning and Locker Service\n */\n\n// Core exports\nexport { Calendar } from './core/calendar/Calendar.js';\nexport { Event } from './core/events/Event.js';\nexport { EventStore } from './core/events/EventStore.js';\nexport { StateManager } from './core/state/StateManager.js';\nexport { DateUtils } from './core/calendar/DateUtils.js';\n\n// Version\nexport const VERSION = '0.1.0';\n\n// Default export\nexport { Calendar as default } from './core/calendar/Calendar.js';"],"names":["TimezoneManager","constructor","this","offsetCache","Map","dstCache","timezoneAbbreviations","EST","EDT","CST","CDT","MST","MDT","PST","PDT","GMT","BST","CET","CEST","JST","IST","AEST","AEDT","timezoneOffsets","UTC","dstRules","start","month","week","day","end","offset","convertTimezone","date","fromTimezone","toTimezone","Date","fromOffset","getTimezoneOffset","offsetDiff","getTime","toUTC","timezone","fromUTC","utcDate","cacheKey","getFullYear","getMonth","getDate","has","get","Intl","DateTimeFormat","parts","timeZone","year","hour","minute","second","hour12","formatToParts","find","p","type","value","set","e","baseOffset","isDST","dstRule","dstStart","getNthWeekdayOfMonth","dstEnd","dayOfWeek","dayOffset","getDay","setDate","lastDay","getCommonTimezones","now","label","region","map","tz","offsetHours","hours","Math","floor","abs","minutes","round","offsetStr","toString","padStart","offsetMinutes","sort","a","b","formatInTimezone","options","formatOptions","format","toLocaleString","getSystemTimezone","resolvedOptions","tzOffset","Object","entries","parseTimezone","tzString","hasOwnProperty","upperTz","toUpperCase","offsetMatch","match","totalOffset","parseInt","getTimezoneDifference","timezone1","timezone2","offset1","clearCache","clear","Event","normalize","data","normalized","allDay","setHours","id","String","trim","title","description","location","attendees","Array","isArray","reminders","categories","attachments","includes","status","visibility","color","backgroundColor","borderColor","validate","Error","isNaN","recurring","recurrenceRule","length","forEach","attendee","index","email","name","test","reminder","method","minutesBefore","textColor","endTimeZone","organizer","conferenceData","metadata","_timezoneManager","startUTC","endUTC","_originalTimeZone","_cache","_validateAttendees","_validateReminders","duration","getStartInTimezone","getEndInTimezone","updateTimes","durationMinutes","durationHours","isMultiDay","startDay","toDateString","endDay","isRecurring","occursOn","dateString","startString","endString","dayStart","dayEnd","overlaps","otherEvent","contains","datetime","clone","updates","r","toObject","toISOString","fromObject","obj","equals","other","addAttendee","hasAttendee","random","substr","responseStatus","role","push","removeAttendee","emailOrId","findIndex","splice","updateAttendeeResponse","getAttendee","responseTime","some","getAttendeesByStatus","filter","getAttendeeCounts","reduce","counts","addReminder","enabled","removeReminder","reminderId","getActiveReminders","getReminderTriggerTimes","triggerTime","setMinutes","getMinutes","addCategory","category","normalizedCategory","toLowerCase","hasCategory","removeCategory","c","hasAnyCategory","hasAllCategories","every","_isValidEmail","isCancelled","isTentative","isConfirmed","isPrivate","isPublic","hasAttendees","hasReminders","isMeeting","isVirtual","DateUtils","startOfDay","result","endOfDay","startOfWeek","weekStartsOn","diff","setTime","endOfWeek","startOfMonth","endOfMonth","startOfYear","endOfYear","addDays","days","addWeeks","weeks","addMonths","months","dayOfMonth","setMonth","addYears","years","setFullYear","isToday","today","isPast","isFuture","isSameDay","date1","date2","isSameWeek","week1Start","week2Start","isSameMonth","isSameYear","differenceInDays","differenceInWeeks","differenceInMonths","getWeekNumber","firstDayOfYear","pastDaysOfYear","ceil","getDayOfWeek","getDaysInMonth","locale","getMonthName","getDayName","weekday","formatTime","use24Hour","parseTime","timeString","split","Number","isLeapYear","getDateRange","dates","current","endTime","isValidDate","toTimeZone","dateObj","part","tzDate","jan","jul","janOffset","julOffset","currentOffset","max","addHoursWithDST","originalOffset","newOffset","dstAdjustment","createInTimeZone","dateStr","timeStr","localDate","utcTime","RecurrenceEngine","expandEvent","event","rangeStart","rangeEnd","maxOccurrences","rule","parseRule","occurrences","eventTimezone","tzManager","currentDate","count","until","lastOffset","occurrenceStart","occurrenceEnd","isException","recurringEventId","originalStart","getNextOccurrence","ruleString","freq","interval","byDay","byMonthDay","byMonth","bySetPos","exceptions","key","parseDate","d","m","next","matchesByDay","currentMonth","setToWeekdayOfMonth","dayMap","SU","MO","TU","WE","TH","FR","SA","weekdayCode","position","targetDay","nextMonth","eventId","dateTime","exDate","exceptionDate","matchTime","addExceptions","reason","endsWith","getDescription","join","toLocaleDateString","dayCode","code","LRUCache","capacity","cache","hits","misses","evictions","delete","put","size","firstKey","keys","getStats","hitRate","toFixed","from","PerformanceOptimizer","config","enableCache","cacheCapacity","maxIndexDays","batchSize","enableMetrics","cleanupInterval","maxIndexAge","eventCache","queryCache","dateRangeCache","lazyIndexes","pendingIndexes","batchQueue","batchTimer","batchCallbacks","metrics","operations","averageTimes","slowQueries","cleanupTimer","startCleanupTimer","measure","operation","fn","performance","recordMetric","error","measureAsync","isError","totalTime","errors","min","Infinity","metric","timestamp","shift","getMetrics","summary","cacheStats","query","dateRange","slowestOperations","recentSlowQueries","slice","op","avgTime","minTime","maxTime","errorRate","time","shouldUseLazyIndexing","createLazyIndexMarkers","markers","indexed","Set","pending","startMonth","endMonth","add","getMonthKey","expandLazyIndex","promise","Promise","resolve","setTimeout","cacheType","getFromCache","invalidateEventCaches","batch","reject","processBatch","clearTimeout","callbacks","results","callback","setInterval","cleanupOldIndexes","maxAge","optimizeQuery","queryKey","queryFn","cached","undefined","destroy","clearInterval","ConflictDetector","eventStore","conflictIdCounter","checkConflicts","opts","checkAttendees","checkResources","checkLocation","ignoreAllDay","excludeEventIds","includeStatuses","bufferMinutes","conflicts","affectedEventIds","affectedAttendees","searchStart","searchEnd","potentialConflicts","getEventsInRange","conflictingEvent","eventConflicts","_detectEventConflicts","_buildConflictSummary","checkEventPairConflicts","event1","event2","getBusyPeriods","attendeeEmails","mergePeriods","busyPeriods","eventIds","_mergeBusyPeriods","getFreePeriods","businessHoursOnly","businessHours","excludeWeekends","freePeriods","_getAllBusyPeriods","currentTime","busy","_isWithinBusinessHours","_checkTimeOverlap","timeConflict","_createTimeConflict","attendeeConflicts","_checkAttendeeConflicts","resourceConflicts","_checkResourceConflicts","locationConflict","_checkLocationConflict","buffer","start1","end1","start2","end2","overlapStart","overlapEnd","overlapMinutes","severity","conflictingEventId","event1Title","event2Title","event1Status","event2Status","conflictingAttendees","attendee1","attendee2","a1","a2","attendeeCount","resources1","resource","resources2","resource1","resource2","conflictingResource","resourceName","resourceEmail","conflictsByType","conflictsBySeverity","conflict","hasConflicts","totalConflicts","periods","merged","i","last","startHour","getHours","endHour","businessStart","businessEnd","EventStore","events","indices","byDate","byCategory","byStatus","timezoneManager","defaultTimezone","optimizer","conflictDetector","isBatchMode","batchNotifications","batchBackup","version","listeners","addEvent","_indexEvent","_notifyChange","updateEvent","existingEvent","_unindexEvent","updatedEvent","oldEvent","removeEvent","getEvent","getAllEvents","values","queryEvents","filters","monthKey","matchAllCategories","organizerEmail","localeCompare","getEventsForDate","startOfDayLocal","endOfDayLocal","timeCompare","getOverlappingEvents","excludeId","overlapping","startDate","endDate","checkedIds","getOverlapGroups","timedOnly","groups","processed","group","currentEvent","calculateEventPositions","positions","startDiff","columns","column","totalColumns","pos","expandRecurring","baseEvents","expandedEvents","expandRecurringEvent","occurrence","occurrenceIndex","oldEvents","loadEvents","eventData","subscribe","_indexEventLazy","firstWeekEnd","lastWeekStart","change","listener","console","totalEvents","recurringEvents","indexedDates","indexedMonths","indexedCategories","indexedStatuses","performanceMetrics","startBatch","enableRollback","k","v","commitBatch","changes","rollbackBatch","executeBatch","addEvents","message","warn","updateEvents","eventUpdates","removeEvents","removed","getPerformanceMetrics","clearCaches","optimizeIndices","cutoffDate","stillNeeded","log","eventId1","eventId2","getAllConflicts","allConflicts","checkedPairs","j","pairKey","addEventWithConflictCheck","allowConflicts","findEventsWithConflicts","eventsWithConflicts","allEvents","StateManager","initialState","state","view","selectedEventId","selectedDate","hoveredEventId","hoveredDate","showWeekNumbers","showWeekends","fixedWeekCount","hourFormat","searchTerm","showAllDay","showTimed","isDragging","isResizing","isCreating","isLoading","loadingMessage","globalListeners","history","historyIndex","maxHistorySize","getState","freeze","setState","oldState","newState","_hasChanged","_addToHistory","_notifyListeners","setView","validViews","setCurrentDate","navigateNext","newDate","navigatePrevious","navigateToday","selectEvent","clearEventSelection","selectDate","clearDateSelection","setLoading","setError","updateFilters","watch","keyArray","canUndo","canRedo","getUndoCount","getRedoCount","undo","previousState","currentState","redo","nextState","reset","_deepEqual","seen","aKeys","bKeys","Calendar","plugins","views","_setupInternalListeners","setEvents","viewType","_emit","getView","direction","previous","goToDate","getCurrentDate","getEvents","setTimezone","parsedTimezone","previousTimezone","getTimezone","toCalendarTimezone","fromCalendarTimezone","getTimezones","getViewData","_getMonthViewData","_getWeekViewData","_getDayViewData","_getListViewData","firstDay","maxWeeks","weekIndex","weekNumber","dayIndex","dayDate","isCurrentMonth","isWeekend","monthName","dayName","overlapGroups","getEventPositions","allDayEvents","timedEvents","hourDate","hourEnd","groupedEvents","dateKey","on","eventName","off","use","plugin","install","uninstall","VERSION"],"mappings":"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"}